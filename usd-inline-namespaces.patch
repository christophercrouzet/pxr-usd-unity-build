diff --git a/pxr/base/arch/demangle.cpp b/pxr/base/arch/demangle.cpp
index 3a59c4047..b3084fd98 100644
--- a/pxr/base/arch/demangle.cpp
+++ b/pxr/base/arch/demangle.cpp
@@ -101,17 +101,17 @@ _FixupStringNames(std::string* name)
 
 #if defined(ARCH_OS_WINDOWS)
     pos = 0;
-    while ((pos = name->find("class ", pos)) != string::npos) {
+    while ((pos = name->find("class ", pos)) != std::string::npos) {
         name->erase(pos, 6);
     }
 
     pos = 0;
-    while ((pos = name->find("struct ", pos)) != string::npos) {
+    while ((pos = name->find("struct ", pos)) != std::string::npos) {
         name->erase(pos, 7);
     }
 
     pos = 0;
-    while ((pos = name->find("enum ", pos)) != string::npos) {
+    while ((pos = name->find("enum ", pos)) != std::string::npos) {
         name->erase(pos, 5);
     }
 #endif
@@ -221,7 +221,7 @@ bool
 ArchDemangle(std::string* mangledTypeName)
 {
 #if defined(_PARANOID_CHECK_MODE)
-    string copy = *mangledTypeName;
+    std::string copy = *mangledTypeName;
     if (_DemangleNew(mangledTypeName)) {
         if (_DemangleOld(&copy) && copy != *mangledTypeName) {
             fprintf(stderr, "ArchDemangle: disagreement between old and new\n"
@@ -260,14 +260,14 @@ Arch_DemangleFunctionName(std::string* mangledFunctionName)
 
 #elif defined(ARCH_OS_WINDOWS)
 
-static string*
+static std::string*
 _NewDemangledStringTypeName()
 {
-    return new string(typeid(string).name());
+    return new std::string(typeid(std::string).name());
 }
 
 bool
-ArchDemangle(string* mangledTypeName)
+ArchDemangle(std::string* mangledTypeName)
 {
     _FixupStringNames(mangledTypeName);
     #if PXR_USE_NAMESPACES
@@ -277,7 +277,7 @@ ArchDemangle(string* mangledTypeName)
 }
 
 void
-Arch_DemangleFunctionName(string* mangledFunctionName)
+Arch_DemangleFunctionName(std::string* mangledFunctionName)
 {
     ArchDemangle(mangledFunctionName);
 }
diff --git a/pxr/base/arch/fileSystem.cpp b/pxr/base/arch/fileSystem.cpp
index 3673b5e94..f49c51c66 100644
--- a/pxr/base/arch/fileSystem.cpp
+++ b/pxr/base/arch/fileSystem.cpp
@@ -299,11 +299,11 @@ _NormPath(std::string const &inPath)
 } // anon
 
 #if defined(ARCH_OS_WINDOWS)
-string
-ArchNormPath(const string& inPath, bool stripDriveSpecifier)
+std::string
+ArchNormPath(const std::string& inPath, bool stripDriveSpecifier)
 {
     // Convert backslashes to forward slashes.
-    string path = inPath;
+    std::string path = inPath;
     std::replace(path.begin(), path.end(), '\\', '/');
 
     // Extract the drive specifier.  Note that we don't correctly handle
@@ -312,7 +312,7 @@ ArchNormPath(const string& inPath, bool stripDriveSpecifier)
     // Also make sure drive letters are always lower-case out of ArchNormPath
     // on Windows -- this is so that we can be sure we can reliably use the
     // paths as keys in tables, etc.
-    string prefix;
+    std::string prefix;
     if (path.size() >= 2 && path[1] == ':') {
         if (!stripDriveSpecifier) {
             prefix.assign(2, ':');
@@ -477,7 +477,7 @@ ArchGetFileName(FILE *file)
     }
     return result;
 #elif defined (ARCH_OS_DARWIN)
-    string result;
+    std::string result;
     char buf[MAXPATHLEN];
     if (fcntl(fileno(file), F_GETPATH, buf) != -1) {
         result = buf;
@@ -488,7 +488,7 @@ ArchGetFileName(FILE *file)
         sizeof(FILE_NAME_INFO) + sizeof(WCHAR) * 4096;
     HANDLE hfile = _FileToWinHANDLE(file);
     auto fileNameInfo = reinterpret_cast<PFILE_NAME_INFO>(malloc(bufSize));
-    string result;
+    std::string result;
     if (GetFileInformationByHandleEx(
             hfile, FileNameInfo, static_cast<void *>(fileNameInfo), bufSize)) {
         size_t outSize = WideCharToMultiByte(
@@ -1186,20 +1186,20 @@ std::string ArchReadLink(const char* path)
 
             // Convert wide-char to narrow char
             std::wstring ws(reparsePath.get());
-            string str(ws.begin(), ws.end());
+            std::string str(ws.begin(), ws.end());
 
             // Symlinks can be absolute, or relative to the parent directory.
             // Deal with the relative case here by prepending the parent path.
             if ((reparse->SymbolicLinkReparseBuffer.Flags &
                  SYMLINK_FLAG_RELATIVE) == SYMLINK_FLAG_RELATIVE)
             {
-                string fullpath = ArchAbsPath(path);
-                string::size_type i = fullpath.find_last_of("/\\");
-                if (i != string::npos)
+                std::string fullpath = ArchAbsPath(path);
+                std::string::size_type i = fullpath.find_last_of("/\\");
+                if (i != std::string::npos)
                 {
                     // Grab the parent directory path, including the trailing
                     // slash, and insert it ahead of the relative symlink path.
-                    string dirpath = fullpath.substr(0, i+1);
+                    std::string dirpath = fullpath.substr(0, i+1);
                     str.insert(0, dirpath);
                 }
             }
@@ -1220,7 +1220,7 @@ std::string ArchReadLink(const char* path)
 
             // Convert wide-char to narrow char
             std::wstring ws(reparsePath.get());
-            string str(ws.begin(), ws.end());
+            std::string str(ws.begin(), ws.end());
 
             // Note that junctions do not support the relative path form
             // like SYMLINKS do, so nothing more to do here.
diff --git a/pxr/base/arch/stackTrace.cpp b/pxr/base/arch/stackTrace.cpp
index fd7e86c67..c21f9e297 100644
--- a/pxr/base/arch/stackTrace.cpp
+++ b/pxr/base/arch/stackTrace.cpp
@@ -1201,7 +1201,7 @@ _LogStackTraceToOutputIterator(OutputIterator oi, size_t maxDepth, bool addEndl)
     _LogStackTraceForPid(logfile);
 
     ifstream inFile(logfile);
-    string line;
+    std::string line;
     size_t currentDepth = 0;
     while(!inFile.eof() && currentDepth < maxDepth) {
         getline(inFile, line);
@@ -1266,7 +1266,7 @@ ArchPrintStackTrace(std::ostream& oss,
 
 #if defined(ARCH_OS_DARWIN)
 
-    _LogStackTraceToOutputIterator(ostream_iterator<string>(oss), numeric_limits<size_t>::max(), true);
+    _LogStackTraceToOutputIterator(ostream_iterator<std::string>(oss), numeric_limits<size_t>::max(), true);
 
 #else
 
@@ -1344,7 +1344,7 @@ ArchGetStackFrames(size_t maxdepth, size_t skip, std::vector<uintptr_t> *frames)
 #elif defined(ARCH_OS_WINDOWS)
 
 void
-ArchGetStackFrames(size_t maxdepth, size_t skip, vector<uintptr_t> *frames)
+ArchGetStackFrames(size_t maxdepth, size_t skip, std::vector<uintptr_t> *frames)
 {
     void* stack[MAX_STACK_DEPTH];
     size_t frameCount = CaptureStackBackTrace(skip, MAX_STACK_DEPTH, stack, NULL);
@@ -1358,7 +1358,7 @@ ArchGetStackFrames(size_t maxdepth, size_t skip, vector<uintptr_t> *frames)
 #elif defined(ARCH_OS_DARWIN)
 
 void
-ArchGetStackFrames(size_t maxdepth, size_t skip, vector<uintptr_t> *frames)
+ArchGetStackFrames(size_t maxdepth, size_t skip, std::vector<uintptr_t> *frames)
 {
     void* stack[MAX_STACK_DEPTH];
     const size_t frameCount =
@@ -1372,7 +1372,7 @@ ArchGetStackFrames(size_t maxdepth, size_t skip, vector<uintptr_t> *frames)
 #else
 
 void
-ArchGetStackFrames(size_t, size_t, vector<uintptr_t> *)
+ArchGetStackFrames(size_t, size_t, std::vector<uintptr_t> *)
 {
 }
 
diff --git a/pxr/base/gf/frustum.cpp b/pxr/base/gf/frustum.cpp
index fdb613f79..c408ae975 100644
--- a/pxr/base/gf/frustum.cpp
+++ b/pxr/base/gf/frustum.cpp
@@ -35,6 +35,7 @@
 #include "pxr/base/tf/type.h"
 
 #include <algorithm>
+#include <cmath>
 #include <ostream>
 
 
@@ -282,7 +283,7 @@ GfFrustum::FitToSphere(const GfVec3d &center, double radius, double slack)
         // the sphere at the point of tangency.
         _viewDistance =
             radius * (1.0/halfSize) *
-             sqrt(GfSqr(halfSize) + GfSqr(_nearFar.GetMin()));
+             std::sqrt(GfSqr(halfSize) + GfSqr(_nearFar.GetMin()));
 
         // XXX.
         // Hmmm. This is not really used anywhere but in tests, so 
diff --git a/pxr/base/gf/matrix3.template.cpp b/pxr/base/gf/matrix3.template.cpp
index c365f53fb..b1d3991d7 100644
--- a/pxr/base/gf/matrix3.template.cpp
+++ b/pxr/base/gf/matrix3.template.cpp
@@ -30,6 +30,7 @@
 {% block customIncludes %}
 #include "pxr/base/gf/quat{{ SCL[0] }}.h"
 #include "pxr/base/gf/rotation.h"
+#include <cmath>
 {% endblock customIncludes %}
 
 {% block customConstructors %}
@@ -225,7 +226,7 @@ GfQuaternion
     double  r;
 
     if (_mtx[0][0] + _mtx[1][1] + _mtx[2][2] > _mtx[i][i]) {
-	r = 0.5 * sqrt(_mtx[0][0] + _mtx[1][1] +
+	r = 0.5 * std::sqrt(_mtx[0][0] + _mtx[1][1] +
 		       _mtx[2][2] + 1);
 	im.Set((_mtx[1][2] - _mtx[2][1]) / (4.0 * r),
 	       (_mtx[2][0] - _mtx[0][2]) / (4.0 * r),
@@ -234,7 +235,7 @@ GfQuaternion
     else {
 	int j = (i + 1) % 3;
 	int k = (i + 2) % 3;
-	double q = 0.5 * sqrt(_mtx[i][i] - _mtx[j][j] -
+	double q = 0.5 * std::sqrt(_mtx[i][i] - _mtx[j][j] -
 			      _mtx[k][k] + 1); 
 
 	im[i] = q;
diff --git a/pxr/base/gf/matrix3d.cpp b/pxr/base/gf/matrix3d.cpp
index dbe954893..a7f31fa85 100644
--- a/pxr/base/gf/matrix3d.cpp
+++ b/pxr/base/gf/matrix3d.cpp
@@ -36,6 +36,7 @@
 
 #include "pxr/base/gf/quatd.h"
 #include "pxr/base/gf/rotation.h"
+#include <cmath>
 #include <float.h>
 #include <ostream>
 
@@ -486,7 +487,7 @@ GfMatrix3d::ExtractRotationQuaternion() const
     double  r;
 
     if (_mtx[0][0] + _mtx[1][1] + _mtx[2][2] > _mtx[i][i]) {
-	r = 0.5 * sqrt(_mtx[0][0] + _mtx[1][1] +
+	r = 0.5 * std::sqrt(_mtx[0][0] + _mtx[1][1] +
 		       _mtx[2][2] + 1);
 	im.Set((_mtx[1][2] - _mtx[2][1]) / (4.0 * r),
 	       (_mtx[2][0] - _mtx[0][2]) / (4.0 * r),
@@ -495,7 +496,7 @@ GfMatrix3d::ExtractRotationQuaternion() const
     else {
 	int j = (i + 1) % 3;
 	int k = (i + 2) % 3;
-	double q = 0.5 * sqrt(_mtx[i][i] - _mtx[j][j] -
+	double q = 0.5 * std::sqrt(_mtx[i][i] - _mtx[j][j] -
 			      _mtx[k][k] + 1); 
 
 	im[i] = q;
diff --git a/pxr/base/gf/matrix3f.cpp b/pxr/base/gf/matrix3f.cpp
index e14ca3800..bd171624a 100644
--- a/pxr/base/gf/matrix3f.cpp
+++ b/pxr/base/gf/matrix3f.cpp
@@ -36,6 +36,7 @@
 
 #include "pxr/base/gf/quatf.h"
 #include "pxr/base/gf/rotation.h"
+#include <cmath>
 #include <float.h>
 #include <ostream>
 
diff --git a/pxr/base/gf/matrix4.template.cpp b/pxr/base/gf/matrix4.template.cpp
index a5c6ceb67..b8686ec4d 100644
--- a/pxr/base/gf/matrix4.template.cpp
+++ b/pxr/base/gf/matrix4.template.cpp
@@ -33,6 +33,7 @@
 #include "pxr/base/gf/matrix3{{ SCL[0] }}.h"
 #include "pxr/base/gf/quat{{ SCL[0] }}.h"
 #include "pxr/base/gf/rotation.h"
+#include <cmath>
 {% endblock customIncludes %}
 
 {% block customConstructors %}
@@ -555,7 +556,7 @@ bool
         if (eigenvalues[i] < eps) {
             (*s)[i] = detSign * eps;
         } else {
-            (*s)[i] = detSign * sqrt(eigenvalues[i]);
+            (*s)[i] = detSign * std::sqrt(eigenvalues[i]);
         }
         sInv._mtx[i][i] = 1.0 / (*s)[i];
     }
@@ -619,14 +620,14 @@ void
 			t = a._mtx[p][q] / h;
 		    } else {
 			double theta = 0.5 * h / a._mtx[p][q];
-			t = 1.0 / (GfAbs(theta) + sqrt(1.0 + theta * theta));
+			t = 1.0 / (GfAbs(theta) + std::sqrt(1.0 + theta * theta));
 			if (theta < 0.0)
 			    t = -t;
 		    }
 
 		    // End of computing tangent of rotation angle
 		    
-		    double c = 1.0 / sqrt(1.0 + t*t);
+		    double c = 1.0 / std::sqrt(1.0 + t*t);
 		    double s = t * c;
 		    double tau = s / (1.0 + c);
 		    h = t * a._mtx[p][q];
@@ -708,7 +709,7 @@ GfQuat{{ SCL[0] }}
     ScalarType  r;
 
     if (_mtx[0][0] + _mtx[1][1] + _mtx[2][2] > _mtx[i][i]) {
-	r = 0.5 * sqrt(_mtx[0][0] + _mtx[1][1] +
+	r = 0.5 * std::sqrt(_mtx[0][0] + _mtx[1][1] +
 		       _mtx[2][2] + _mtx[3][3]);
 	im.Set((_mtx[1][2] - _mtx[2][1]) / (4.0 * r),
 	       (_mtx[2][0] - _mtx[0][2]) / (4.0 * r),
@@ -717,7 +718,7 @@ GfQuat{{ SCL[0] }}
     else {
 	int j = (i + 1) % 3;
 	int k = (i + 2) % 3;
-	ScalarType q = 0.5 * sqrt(_mtx[i][i] - _mtx[j][j] -
+	ScalarType q = 0.5 * std::sqrt(_mtx[i][i] - _mtx[j][j] -
 			      _mtx[k][k] + _mtx[3][3]); 
 
 	im[i] = q;
diff --git a/pxr/base/gf/matrix4d.cpp b/pxr/base/gf/matrix4d.cpp
index 0049580f3..dc588ecb2 100644
--- a/pxr/base/gf/matrix4d.cpp
+++ b/pxr/base/gf/matrix4d.cpp
@@ -38,6 +38,7 @@
 #include "pxr/base/gf/matrix3d.h"
 #include "pxr/base/gf/quatd.h"
 #include "pxr/base/gf/rotation.h"
+#include <cmath>
 #include <float.h>
 #include <ostream>
 
@@ -946,7 +947,7 @@ GfMatrix4d::Factor(GfMatrix4d* r, GfVec3d* s, GfMatrix4d* u,
         if (eigenvalues[i] < eps) {
             (*s)[i] = detSign * eps;
         } else {
-            (*s)[i] = detSign * sqrt(eigenvalues[i]);
+            (*s)[i] = detSign * std::sqrt(eigenvalues[i]);
         }
         sInv._mtx[i][i] = 1.0 / (*s)[i];
     }
@@ -1005,14 +1006,14 @@ GfMatrix4d::_Jacobi3(GfVec3d *eigenvalues, GfVec3d eigenvectors[3]) const
 			t = a._mtx[p][q] / h;
 		    } else {
 			double theta = 0.5 * h / a._mtx[p][q];
-			t = 1.0 / (GfAbs(theta) + sqrt(1.0 + theta * theta));
+			t = 1.0 / (GfAbs(theta) + std::sqrt(1.0 + theta * theta));
 			if (theta < 0.0)
 			    t = -t;
 		    }
 
 		    // End of computing tangent of rotation angle
 		    
-		    double c = 1.0 / sqrt(1.0 + t*t);
+		    double c = 1.0 / std::sqrt(1.0 + t*t);
 		    double s = t * c;
 		    double tau = s / (1.0 + c);
 		    h = t * a._mtx[p][q];
@@ -1094,7 +1095,7 @@ GfMatrix4d::ExtractRotationQuat() const
     ScalarType  r;
 
     if (_mtx[0][0] + _mtx[1][1] + _mtx[2][2] > _mtx[i][i]) {
-	r = 0.5 * sqrt(_mtx[0][0] + _mtx[1][1] +
+	r = 0.5 * std::sqrt(_mtx[0][0] + _mtx[1][1] +
 		       _mtx[2][2] + _mtx[3][3]);
 	im.Set((_mtx[1][2] - _mtx[2][1]) / (4.0 * r),
 	       (_mtx[2][0] - _mtx[0][2]) / (4.0 * r),
@@ -1103,7 +1104,7 @@ GfMatrix4d::ExtractRotationQuat() const
     else {
 	int j = (i + 1) % 3;
 	int k = (i + 2) % 3;
-	ScalarType q = 0.5 * sqrt(_mtx[i][i] - _mtx[j][j] -
+	ScalarType q = 0.5 * std::sqrt(_mtx[i][i] - _mtx[j][j] -
 			      _mtx[k][k] + _mtx[3][3]); 
 
 	im[i] = q;
diff --git a/pxr/base/gf/matrix4f.cpp b/pxr/base/gf/matrix4f.cpp
index 0d193f123..adb894b2e 100644
--- a/pxr/base/gf/matrix4f.cpp
+++ b/pxr/base/gf/matrix4f.cpp
@@ -38,6 +38,7 @@
 #include "pxr/base/gf/matrix3f.h"
 #include "pxr/base/gf/quatf.h"
 #include "pxr/base/gf/rotation.h"
+#include <cmath>
 #include <float.h>
 #include <ostream>
 
@@ -924,7 +925,7 @@ GfMatrix4f::Factor(GfMatrix4f* r, GfVec3f* s, GfMatrix4f* u,
         if (eigenvalues[i] < eps) {
             (*s)[i] = detSign * eps;
         } else {
-            (*s)[i] = detSign * sqrt(eigenvalues[i]);
+            (*s)[i] = detSign * std::sqrt(eigenvalues[i]);
         }
         sInv._mtx[i][i] = 1.0 / (*s)[i];
     }
@@ -984,14 +985,14 @@ GfMatrix4f::_Jacobi3(GfVec3d *eigenvalues, GfVec3d eigenvectors[3]) const
 			t = a._mtx[p][q] / h;
 		    } else {
 			double theta = 0.5 * h / a._mtx[p][q];
-			t = 1.0 / (GfAbs(theta) + sqrt(1.0 + theta * theta));
+			t = 1.0 / (GfAbs(theta) + std::sqrt(1.0 + theta * theta));
 			if (theta < 0.0)
 			    t = -t;
 		    }
 
 		    // End of computing tangent of rotation angle
 		    
-		    double c = 1.0 / sqrt(1.0 + t*t);
+		    double c = 1.0 / std::sqrt(1.0 + t*t);
 		    double s = t * c;
 		    double tau = s / (1.0 + c);
 		    h = t * a._mtx[p][q];
diff --git a/pxr/base/gf/quat.template.cpp b/pxr/base/gf/quat.template.cpp
index eb77d14a9..ce3169dba 100644
--- a/pxr/base/gf/quat.template.cpp
+++ b/pxr/base/gf/quat.template.cpp
@@ -35,6 +35,8 @@
 #include "pxr/base/gf/quat{{ SCALAR_SUFFIX(S) }}.h"
 {% endfor %}
 
+#include <cmath>
+
 PXR_NAMESPACE_OPEN_SCOPE
 
 TF_REGISTRY_FUNCTION(TfType) {
@@ -186,11 +188,11 @@ GfSlerp(double alpha, const {{ QUAT }}& q0, const {{ QUAT }}& q1)
 
     if (1.0 - cosTheta > 0.00001 ) {
         // standard case
-        {{ SCL }} theta = acos(cosTheta),
-               sinTheta = sin(theta);
+        {{ SCL }} theta = std::acos(cosTheta),
+               sinTheta = std::sin(theta);
 
-        scale0 = sin((1.0 - alpha) * theta) / sinTheta;
-        scale1 = sin(alpha * theta) / sinTheta;
+        scale0 = std::sin((1.0 - alpha) * theta) / sinTheta;
+        scale1 = std::sin(alpha * theta) / sinTheta;
     } else {        
         // rot0 and rot1 very close - just do linear interp and renormalize.
         scale0 = 1.0 - alpha;
diff --git a/pxr/base/gf/quatd.cpp b/pxr/base/gf/quatd.cpp
index 10444378b..cac2ed066 100644
--- a/pxr/base/gf/quatd.cpp
+++ b/pxr/base/gf/quatd.cpp
@@ -34,6 +34,8 @@
 #include "pxr/base/gf/quatf.h"
 #include "pxr/base/gf/quath.h"
 
+#include <cmath>
+
 PXR_NAMESPACE_OPEN_SCOPE
 
 TF_REGISTRY_FUNCTION(TfType) {
@@ -188,11 +190,11 @@ GfSlerp(double alpha, const GfQuatd& q0, const GfQuatd& q1)
 
     if (1.0 - cosTheta > 0.00001 ) {
         // standard case
-        double theta = acos(cosTheta),
-               sinTheta = sin(theta);
+        double theta = std::acos(cosTheta),
+               sinTheta = std::sin(theta);
 
-        scale0 = sin((1.0 - alpha) * theta) / sinTheta;
-        scale1 = sin(alpha * theta) / sinTheta;
+        scale0 = std::sin((1.0 - alpha) * theta) / sinTheta;
+        scale1 = std::sin(alpha * theta) / sinTheta;
     } else {        
         // rot0 and rot1 very close - just do linear interp and renormalize.
         scale0 = 1.0 - alpha;
diff --git a/pxr/base/gf/quaternion.cpp b/pxr/base/gf/quaternion.cpp
index ccbff0a9d..25d962810 100644
--- a/pxr/base/gf/quaternion.cpp
+++ b/pxr/base/gf/quaternion.cpp
@@ -28,6 +28,7 @@
 #include "pxr/base/gf/ostreamHelpers.h"
 #include "pxr/base/tf/type.h"
 
+#include <cmath>
 #include <ostream>
 
 PXR_NAMESPACE_OPEN_SCOPE
@@ -41,14 +42,14 @@ TF_REGISTRY_FUNCTION(TfType) {
 double
 GfQuaternion::GetLength() const
 {
-    return sqrt(_GetLengthSquared());
+    return std::sqrt(_GetLengthSquared());
 }
 
 
 GfQuaternion
 GfQuaternion::GetNormalized(double eps) const
 {
-    double length = sqrt(_GetLengthSquared());
+    double length = std::sqrt(_GetLengthSquared());
 
     if (length < eps)
         return GetIdentity();
@@ -59,7 +60,7 @@ GfQuaternion::GetNormalized(double eps) const
 double
 GfQuaternion::Normalize(double eps)
 {
-    double length = sqrt(_GetLengthSquared());
+    double length = std::sqrt(_GetLengthSquared());
 
     if (length < eps)
         *this = GetIdentity();
@@ -125,11 +126,11 @@ GfSlerp(double alpha, const GfQuaternion& q0, const GfQuaternion& q1)
 
     if (1.0 - cosTheta > 0.00001 ) {
         // standard case
-        double theta = acos(cosTheta),
-               sinTheta = sin(theta);
+        double theta = std::acos(cosTheta),
+               sinTheta = std::sin(theta);
 
-        scale0 = sin((1.0 - alpha) * theta) / sinTheta;
-        scale1 = sin(alpha * theta) / sinTheta;
+        scale0 = std::sin((1.0 - alpha) * theta) / sinTheta;
+        scale1 = std::sin(alpha * theta) / sinTheta;
     } else {        
         // rot0 and rot1 very close - just do linear interp and renormalize.
         scale0 = 1.0 - alpha;
diff --git a/pxr/base/gf/quatf.cpp b/pxr/base/gf/quatf.cpp
index 0051cf640..3874902ee 100644
--- a/pxr/base/gf/quatf.cpp
+++ b/pxr/base/gf/quatf.cpp
@@ -34,6 +34,8 @@
 #include "pxr/base/gf/quatd.h"
 #include "pxr/base/gf/quath.h"
 
+#include <cmath>
+
 PXR_NAMESPACE_OPEN_SCOPE
 
 TF_REGISTRY_FUNCTION(TfType) {
@@ -188,11 +190,11 @@ GfSlerp(double alpha, const GfQuatf& q0, const GfQuatf& q1)
 
     if (1.0 - cosTheta > 0.00001 ) {
         // standard case
-        float theta = acos(cosTheta),
+        float theta = std::acos(cosTheta),
                sinTheta = std::sin(theta);
 
-        scale0 = sin((1.0 - alpha) * theta) / sinTheta;
-        scale1 = sin(alpha * theta) / sinTheta;
+        scale0 = std::sin((1.0 - alpha) * theta) / sinTheta;
+        scale1 = std::sin(alpha * theta) / sinTheta;
     } else {        
         // rot0 and rot1 very close - just do linear interp and renormalize.
         scale0 = 1.0 - alpha;
diff --git a/pxr/base/gf/quath.cpp b/pxr/base/gf/quath.cpp
index a2cfa7c48..3953b58dc 100644
--- a/pxr/base/gf/quath.cpp
+++ b/pxr/base/gf/quath.cpp
@@ -34,6 +34,8 @@
 #include "pxr/base/gf/quatd.h"
 #include "pxr/base/gf/quatf.h"
 
+#include <cmath>
+
 PXR_NAMESPACE_OPEN_SCOPE
 
 TF_REGISTRY_FUNCTION(TfType) {
@@ -188,11 +190,11 @@ GfSlerp(double alpha, const GfQuath& q0, const GfQuath& q1)
 
     if (1.0 - cosTheta > 0.00001 ) {
         // standard case
-        GfHalf theta = acos(cosTheta),
+        GfHalf theta = std::acos(cosTheta),
                sinTheta = std::sin(theta);
 
-        scale0 = sin((1.0 - alpha) * theta) / sinTheta;
-        scale1 = sin(alpha * theta) / sinTheta;
+        scale0 = std::sin((1.0 - alpha) * theta) / sinTheta;
+        scale1 = std::sin(alpha * theta) / sinTheta;
     } else {        
         // rot0 and rot1 very close - just do linear interp and renormalize.
         scale0 = 1.0 - alpha;
diff --git a/pxr/base/gf/rotation.cpp b/pxr/base/gf/rotation.cpp
index d7e996939..4da88120c 100644
--- a/pxr/base/gf/rotation.cpp
+++ b/pxr/base/gf/rotation.cpp
@@ -32,6 +32,7 @@
 #include "pxr/base/tf/diagnosticLite.h"
 #include "pxr/base/tf/type.h"
 
+#include <cmath>
 #include <ostream>
 
 PXR_NAMESPACE_OPEN_SCOPE
@@ -50,7 +51,7 @@ GfRotation::SetQuat(const GfQuatd &quat)
         // Pass through the public API which normalizes axis.
         // Otherwise, it would be possible to create GfRotations using
         // SetQuaternion which cannot be re-created via SetAxisAngle().
-        double x = acos(GfClamp(quat.GetReal(), -1.0, 1.0));
+        double x = std::acos(GfClamp(quat.GetReal(), -1.0, 1.0));
         SetAxisAngle(quat.GetImaginary() / len, 2.0 * GfRadiansToDegrees(x));
     }
     else
@@ -86,7 +87,7 @@ GfRotation::SetRotateInto(const GfVec3d &rotateFrom, const GfVec3d &rotateTo)
     // Generic case: compute the rotation to bring the vectors
     // together.
     GfVec3d axis = GfCross(rotateFrom, rotateTo).GetNormalized();
-    return SetAxisAngle(axis, GfRadiansToDegrees(acos(cos)));
+    return SetAxisAngle(axis, GfRadiansToDegrees(std::acos(cos)));
 }
 
 GfQuatd
@@ -141,7 +142,7 @@ GfRotation::Decompose( const GfVec3d &axis0,
     // Euler Angle Conversion by Ken Shoemake.
     int i = 0, j = 1, k = 2;
     double r0, r1, r2;
-    double cy = sqrt(m[i][i]*m[i][i] + m[j][i]*m[j][i]);
+    double cy = std::sqrt(m[i][i]*m[i][i] + m[j][i]*m[j][i]);
     if (cy > _GetEpsilon()) {
         r0 = atan2(m[k][j], m[k][k]);
         r1 = atan2(-m[k][i], cy);
@@ -618,7 +619,7 @@ GfRotation::ComposeRotation(double         tw,
                         fbAxis(1,0,0),
                         lrAxis(0,1,0);
 
-    vector<GfMatrix4d> matVec;
+    std::vector<GfMatrix4d> matVec;
     matVec.resize(4);
     matVec[0].SetRotate(GfRotation(twAxis,tw));
     matVec[1].SetRotate(GfRotation(fbAxis,fb));
@@ -662,7 +663,7 @@ GfRotation::operator *=(const GfRotation &r)
     double len = q.GetImaginary().GetLength();
     if (len > GF_MIN_VECTOR_LENGTH) {
         _axis  = q.GetImaginary() / len;
-        _angle = 2.0 * GfRadiansToDegrees(acos(q.GetReal()));
+        _angle = 2.0 * GfRadiansToDegrees(std::acos(q.GetReal()));
     }
     else {
         // Leave the axis as is; just set the angle to 0.
diff --git a/pxr/base/gf/vec.template.cpp b/pxr/base/gf/vec.template.cpp
index 20e22db5e..3d453826a 100644
--- a/pxr/base/gf/vec.template.cpp
+++ b/pxr/base/gf/vec.template.cpp
@@ -222,7 +222,7 @@ GfSlerp(double alpha, const {{ VEC }} &v0, const {{ VEC }} &v1)
     // determine the angle between the two lines going from the center of
     // the sphere to v0 and v1.  the projection (dot prod) of one onto the
     // other gives us the arc cosine of the angle between them.
-    double angle = acos(GfClamp((double)GfDot(v0, v1), -1.0, 1.0));
+    double angle = std::acos(GfClamp((double)GfDot(v0, v1), -1.0, 1.0));
 
     // Check for very small angle between the vectors, and if so, just lerp them.
     // XXX: This value for epsilon is somewhat arbitrary, and if
@@ -232,7 +232,7 @@ GfSlerp(double alpha, const {{ VEC }} &v0, const {{ VEC }} &v1)
     }
 
     // compute the sin of the angle, we need it a couple of places
-    double sinAngle = sin(angle);
+    double sinAngle = std::sin(angle);
 
     // Check if the vectors are nearly opposing, and if so,
     // compute an arbitrary orthogonal vector to interpolate across.
@@ -241,7 +241,7 @@ GfSlerp(double alpha, const {{ VEC }} &v0, const {{ VEC }} &v1)
     if ( fabs(sinAngle) < 0.00001 ) {
         {{ VEC }} vX, vY;
         v0.BuildOrthonormalFrame(&vX, &vY);
-        {{ VEC }} v = v0 * cos(alpha*M_PI) + vX * sin(alpha*M_PI);
+        {{ VEC }} v = v0 * std::cos(alpha*M_PI) + vX * std::sin(alpha*M_PI);
         return v;
     }
 
@@ -249,8 +249,8 @@ GfSlerp(double alpha, const {{ VEC }} &v0, const {{ VEC }} &v1)
     double oneOverSinAngle = 1.0 / sinAngle;
 
     return
-        v0 * (sin((1.0-alpha)*angle) * oneOverSinAngle) +
-        v1 * (sin(     alpha *angle) * oneOverSinAngle);
+        v0 * (std::sin((1.0-alpha)*angle) * oneOverSinAngle) +
+        v1 * (std::sin(     alpha *angle) * oneOverSinAngle);
 }
 
 {% endif %}
diff --git a/pxr/base/gf/vec.template.h b/pxr/base/gf/vec.template.h
index ca6779adf..4b6ed7562 100644
--- a/pxr/base/gf/vec.template.h
+++ b/pxr/base/gf/vec.template.h
@@ -253,7 +253,7 @@ public:
     /// Length
     {{ SCL }} GetLength() const {
         // TODO should use GfSqrt.
-        return sqrt(GetLengthSq());
+        return std::sqrt(GetLengthSq());
     }
 
     /// Normalizes the vector in place to unit length, returning the
diff --git a/pxr/base/gf/vec2d.h b/pxr/base/gf/vec2d.h
index 0f9811afd..59e6e7b27 100644
--- a/pxr/base/gf/vec2d.h
+++ b/pxr/base/gf/vec2d.h
@@ -249,7 +249,7 @@ public:
     /// Length
     double GetLength() const {
         // TODO should use GfSqrt.
-        return sqrt(GetLengthSq());
+        return std::sqrt(GetLengthSq());
     }
 
     /// Normalizes the vector in place to unit length, returning the
diff --git a/pxr/base/gf/vec2f.h b/pxr/base/gf/vec2f.h
index c02b03132..c808b6fcf 100644
--- a/pxr/base/gf/vec2f.h
+++ b/pxr/base/gf/vec2f.h
@@ -249,7 +249,7 @@ public:
     /// Length
     float GetLength() const {
         // TODO should use GfSqrt.
-        return sqrt(GetLengthSq());
+        return std::sqrt(GetLengthSq());
     }
 
     /// Normalizes the vector in place to unit length, returning the
diff --git a/pxr/base/gf/vec2h.h b/pxr/base/gf/vec2h.h
index c0b0e23a2..74db42650 100644
--- a/pxr/base/gf/vec2h.h
+++ b/pxr/base/gf/vec2h.h
@@ -250,7 +250,7 @@ public:
     /// Length
     GfHalf GetLength() const {
         // TODO should use GfSqrt.
-        return sqrt(GetLengthSq());
+        return std::sqrt(GetLengthSq());
     }
 
     /// Normalizes the vector in place to unit length, returning the
diff --git a/pxr/base/gf/vec3d.cpp b/pxr/base/gf/vec3d.cpp
index fb9d1422a..fae343452 100644
--- a/pxr/base/gf/vec3d.cpp
+++ b/pxr/base/gf/vec3d.cpp
@@ -237,7 +237,7 @@ GfSlerp(double alpha, const GfVec3d &v0, const GfVec3d &v1)
     // determine the angle between the two lines going from the center of
     // the sphere to v0 and v1.  the projection (dot prod) of one onto the
     // other gives us the arc cosine of the angle between them.
-    double angle = acos(GfClamp((double)GfDot(v0, v1), -1.0, 1.0));
+    double angle = std::acos(GfClamp((double)GfDot(v0, v1), -1.0, 1.0));
 
     // Check for very small angle between the vectors, and if so, just lerp them.
     // XXX: This value for epsilon is somewhat arbitrary, and if
@@ -247,7 +247,7 @@ GfSlerp(double alpha, const GfVec3d &v0, const GfVec3d &v1)
     }
 
     // compute the sin of the angle, we need it a couple of places
-    double sinAngle = sin(angle);
+    double sinAngle = std::sin(angle);
 
     // Check if the vectors are nearly opposing, and if so,
     // compute an arbitrary orthogonal vector to interpolate across.
@@ -256,7 +256,7 @@ GfSlerp(double alpha, const GfVec3d &v0, const GfVec3d &v1)
     if ( fabs(sinAngle) < 0.00001 ) {
         GfVec3d vX, vY;
         v0.BuildOrthonormalFrame(&vX, &vY);
-        GfVec3d v = v0 * cos(alpha*M_PI) + vX * sin(alpha*M_PI);
+        GfVec3d v = v0 * std::cos(alpha*M_PI) + vX * std::sin(alpha*M_PI);
         return v;
     }
 
@@ -264,8 +264,8 @@ GfSlerp(double alpha, const GfVec3d &v0, const GfVec3d &v1)
     double oneOverSinAngle = 1.0 / sinAngle;
 
     return
-        v0 * (sin((1.0-alpha)*angle) * oneOverSinAngle) +
-        v1 * (sin(     alpha *angle) * oneOverSinAngle);
+        v0 * (std::sin((1.0-alpha)*angle) * oneOverSinAngle) +
+        v1 * (std::sin(     alpha *angle) * oneOverSinAngle);
 }
 
 
diff --git a/pxr/base/gf/vec3d.h b/pxr/base/gf/vec3d.h
index 960201de7..5ca5d95f3 100644
--- a/pxr/base/gf/vec3d.h
+++ b/pxr/base/gf/vec3d.h
@@ -261,7 +261,7 @@ public:
     /// Length
     double GetLength() const {
         // TODO should use GfSqrt.
-        return sqrt(GetLengthSq());
+        return std::sqrt(GetLengthSq());
     }
 
     /// Normalizes the vector in place to unit length, returning the
diff --git a/pxr/base/gf/vec3f.cpp b/pxr/base/gf/vec3f.cpp
index e6cb38655..dcd249542 100644
--- a/pxr/base/gf/vec3f.cpp
+++ b/pxr/base/gf/vec3f.cpp
@@ -237,7 +237,7 @@ GfSlerp(double alpha, const GfVec3f &v0, const GfVec3f &v1)
     // determine the angle between the two lines going from the center of
     // the sphere to v0 and v1.  the projection (dot prod) of one onto the
     // other gives us the arc cosine of the angle between them.
-    double angle = acos(GfClamp((double)GfDot(v0, v1), -1.0, 1.0));
+    double angle = std::acos(GfClamp((double)GfDot(v0, v1), -1.0, 1.0));
 
     // Check for very small angle between the vectors, and if so, just lerp them.
     // XXX: This value for epsilon is somewhat arbitrary, and if
@@ -247,7 +247,7 @@ GfSlerp(double alpha, const GfVec3f &v0, const GfVec3f &v1)
     }
 
     // compute the sin of the angle, we need it a couple of places
-    double sinAngle = sin(angle);
+    double sinAngle = std::sin(angle);
 
     // Check if the vectors are nearly opposing, and if so,
     // compute an arbitrary orthogonal vector to interpolate across.
@@ -256,7 +256,7 @@ GfSlerp(double alpha, const GfVec3f &v0, const GfVec3f &v1)
     if ( fabs(sinAngle) < 0.00001 ) {
         GfVec3f vX, vY;
         v0.BuildOrthonormalFrame(&vX, &vY);
-        GfVec3f v = v0 * cos(alpha*M_PI) + vX * sin(alpha*M_PI);
+        GfVec3f v = v0 * std::cos(alpha*M_PI) + vX * std::sin(alpha*M_PI);
         return v;
     }
 
@@ -264,8 +264,8 @@ GfSlerp(double alpha, const GfVec3f &v0, const GfVec3f &v1)
     double oneOverSinAngle = 1.0 / sinAngle;
 
     return
-        v0 * (sin((1.0-alpha)*angle) * oneOverSinAngle) +
-        v1 * (sin(     alpha *angle) * oneOverSinAngle);
+        v0 * (std::sin((1.0-alpha)*angle) * oneOverSinAngle) +
+        v1 * (std::sin(     alpha *angle) * oneOverSinAngle);
 }
 
 
diff --git a/pxr/base/gf/vec3f.h b/pxr/base/gf/vec3f.h
index c5c2800bb..2f6bfb142 100644
--- a/pxr/base/gf/vec3f.h
+++ b/pxr/base/gf/vec3f.h
@@ -261,7 +261,7 @@ public:
     /// Length
     float GetLength() const {
         // TODO should use GfSqrt.
-        return sqrt(GetLengthSq());
+        return std::sqrt(GetLengthSq());
     }
 
     /// Normalizes the vector in place to unit length, returning the
diff --git a/pxr/base/gf/vec3h.cpp b/pxr/base/gf/vec3h.cpp
index 13f1d56f0..fb39403d9 100644
--- a/pxr/base/gf/vec3h.cpp
+++ b/pxr/base/gf/vec3h.cpp
@@ -237,7 +237,7 @@ GfSlerp(double alpha, const GfVec3h &v0, const GfVec3h &v1)
     // determine the angle between the two lines going from the center of
     // the sphere to v0 and v1.  the projection (dot prod) of one onto the
     // other gives us the arc cosine of the angle between them.
-    double angle = acos(GfClamp((double)GfDot(v0, v1), -1.0, 1.0));
+    double angle = std::acos(GfClamp((double)GfDot(v0, v1), -1.0, 1.0));
 
     // Check for very small angle between the vectors, and if so, just lerp them.
     // XXX: This value for epsilon is somewhat arbitrary, and if
@@ -247,7 +247,7 @@ GfSlerp(double alpha, const GfVec3h &v0, const GfVec3h &v1)
     }
 
     // compute the sin of the angle, we need it a couple of places
-    double sinAngle = sin(angle);
+    double sinAngle = std::sin(angle);
 
     // Check if the vectors are nearly opposing, and if so,
     // compute an arbitrary orthogonal vector to interpolate across.
@@ -256,7 +256,7 @@ GfSlerp(double alpha, const GfVec3h &v0, const GfVec3h &v1)
     if ( fabs(sinAngle) < 0.00001 ) {
         GfVec3h vX, vY;
         v0.BuildOrthonormalFrame(&vX, &vY);
-        GfVec3h v = v0 * cos(alpha*M_PI) + vX * sin(alpha*M_PI);
+        GfVec3h v = v0 * std::cos(alpha*M_PI) + vX * std::sin(alpha*M_PI);
         return v;
     }
 
@@ -264,8 +264,8 @@ GfSlerp(double alpha, const GfVec3h &v0, const GfVec3h &v1)
     double oneOverSinAngle = 1.0 / sinAngle;
 
     return
-        v0 * (sin((1.0-alpha)*angle) * oneOverSinAngle) +
-        v1 * (sin(     alpha *angle) * oneOverSinAngle);
+        v0 * (std::sin((1.0-alpha)*angle) * oneOverSinAngle) +
+        v1 * (std::sin(     alpha *angle) * oneOverSinAngle);
 }
 
 
diff --git a/pxr/base/gf/vec3h.h b/pxr/base/gf/vec3h.h
index 847ab6d49..042b82e43 100644
--- a/pxr/base/gf/vec3h.h
+++ b/pxr/base/gf/vec3h.h
@@ -262,7 +262,7 @@ public:
     /// Length
     GfHalf GetLength() const {
         // TODO should use GfSqrt.
-        return sqrt(GetLengthSq());
+        return std::sqrt(GetLengthSq());
     }
 
     /// Normalizes the vector in place to unit length, returning the
diff --git a/pxr/base/gf/vec4d.h b/pxr/base/gf/vec4d.h
index 4ef934425..a52a565b4 100644
--- a/pxr/base/gf/vec4d.h
+++ b/pxr/base/gf/vec4d.h
@@ -273,7 +273,7 @@ public:
     /// Length
     double GetLength() const {
         // TODO should use GfSqrt.
-        return sqrt(GetLengthSq());
+        return std::sqrt(GetLengthSq());
     }
 
     /// Normalizes the vector in place to unit length, returning the
diff --git a/pxr/base/gf/vec4f.h b/pxr/base/gf/vec4f.h
index f21f30b3c..e9006cf5a 100644
--- a/pxr/base/gf/vec4f.h
+++ b/pxr/base/gf/vec4f.h
@@ -273,7 +273,7 @@ public:
     /// Length
     float GetLength() const {
         // TODO should use GfSqrt.
-        return sqrt(GetLengthSq());
+        return std::sqrt(GetLengthSq());
     }
 
     /// Normalizes the vector in place to unit length, returning the
diff --git a/pxr/base/gf/vec4h.h b/pxr/base/gf/vec4h.h
index d1f5ec015..da198f0ca 100644
--- a/pxr/base/gf/vec4h.h
+++ b/pxr/base/gf/vec4h.h
@@ -274,7 +274,7 @@ public:
     /// Length
     GfHalf GetLength() const {
         // TODO should use GfSqrt.
-        return sqrt(GetLengthSq());
+        return std::sqrt(GetLengthSq());
     }
 
     /// Normalizes the vector in place to unit length, returning the
diff --git a/pxr/base/gf/wrapMatrix.template.cpp b/pxr/base/gf/wrapMatrix.template.cpp
index ad14bb63d..6b2147d00 100644
--- a/pxr/base/gf/wrapMatrix.template.cpp
+++ b/pxr/base/gf/wrapMatrix.template.cpp
@@ -51,9 +51,6 @@
 #include <string>
 #include <vector>
 
-using namespace boost::python;
-using std::string;
-using std::vector;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -71,7 +68,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    {{ MAT }} &mat = extract<{{ MAT }} &>(self);
+    {{ MAT }} &mat = boost::python::extract<{{ MAT }} &>(self);
     *ptrptr = static_cast<void *>(mat.GetArray());
     // Return size in bytes.
     return sizeof({{ MAT }});
@@ -115,7 +112,7 @@ getbuffer(PyObject *self, Py_buffer *view, int flags) {
         return -1;
     }
 
-    {{ MAT }} &mat = extract<{{ MAT }} &>(self);
+    {{ MAT }} &mat = boost::python::extract<{{ MAT }} &>(self);
 
     view->obj = self;
     view->buf = static_cast<void *>(mat.GetArray());
@@ -165,7 +162,7 @@ static PyBufferProcs bufferProcs = {
 // End python buffer protocol support.
 ////////////////////////////////////////////////////////////////////////
 
-static string _Repr({{ MAT }} const &self) {
+static std::string _Repr({{ MAT }} const &self) {
     static char newline[] = ",\n            ";
     return TF_PY_REPR_PREFIX + "Matrix{{ SUFFIX }}(" +
 {% for ROW in range(DIM) %}
@@ -195,11 +192,11 @@ static int __len__({{ MAT }} const &self) {
     return {{ DIM }};
 }
 
-static {{ SCL }} __getitem__{{ SCL }}({{ MAT }} const &self, tuple index) {
+static {{ SCL }} __getitem__{{ SCL }}({{ MAT }} const &self, boost::python::tuple index) {
     int i1=0, i2=0;
-    if (len(index) == 2) {
-        i1 = normalizeIndex(extract<int>(index[0]));
-        i2 = normalizeIndex(extract<int>(index[1]));
+    if (boost::python::len(index) == 2) {
+        i1 = normalizeIndex(boost::python::extract<int>(index[0]));
+        i2 = normalizeIndex(boost::python::extract<int>(index[1]));
     } else
         throwIndexErr("Index has incorrect size.");
 
@@ -210,11 +207,11 @@ static GfVec{{ SUFFIX }} __getitem__vector({{ MAT }} const &self, int index) {
     return GfVec{{ SUFFIX }}(self[normalizeIndex(index)]);
 }
 
-static void __setitem__{{ SCL }}({{ MAT }} &self, tuple index, {{ SCL }} value) {
+static void __setitem__{{ SCL }}({{ MAT }} &self, boost::python::tuple index, {{ SCL }} value) {
     int i1=0, i2=0;
-    if (len(index) == 2) {
-        i1 = normalizeIndex(extract<int>(index[0]));
-        i2 = normalizeIndex(extract<int>(index[1]));
+    if (boost::python::len(index) == 2) {
+        i1 = normalizeIndex(boost::python::extract<int>(index[0]));
+        i2 = normalizeIndex(boost::python::extract<int>(index[1]));
     } else
         throwIndexErr("Index has incorrect size.");
 
@@ -281,7 +278,7 @@ static boost::python::tuple get_dimension()
     // It seems likely that this has to do with the order of
     // destruction of these objects when deinitializing, but we did
     // not dig deeply into this difference.
-    return make_tuple({{ DIM }}, {{ DIM }});
+    return boost::python::make_tuple({{ DIM }}, {{ DIM }});
 }
 
 } // anonymous namespace 
@@ -290,23 +287,23 @@ void wrapMatrix{{ SUFFIX }}()
 {    
     typedef {{ MAT }} This;
 
-    def("IsClose", (bool (*)(const {{ MAT}} &m1, const {{ MAT }} &m2, double))
+    boost::python::def("IsClose", (bool (*)(const {{ MAT}} &m1, const {{ MAT }} &m2, double))
         GfIsClose);
     
-    class_<This> cls( "Matrix{{ SUFFIX }}", no_init);
+    boost::python::class_<This> cls( "Matrix{{ SUFFIX }}", boost::python::no_init);
     cls
         .def_pickle({{ MAT }}_Pickle_Suite())
-	.def("__init__", make_constructor(__init__))
-        .def(init< const GfMatrix{{ DIM }}d & >())
-        .def(init< const GfMatrix{{ DIM }}f & >())
-        .def(init< int >())
-        .def(init< {{ SCL }} >())
-        .def(init<
+	.def("__init__", boost::python::make_constructor(__init__))
+        .def(boost::python::init< const GfMatrix{{ DIM }}d & >())
+        .def(boost::python::init< const GfMatrix{{ DIM }}f & >())
+        .def(boost::python::init< int >())
+        .def(boost::python::init< {{ SCL }} >())
+        .def(boost::python::init<
              {{ MATRIX(SCL, indent=13) }} 
              >())
-        .def(init< const GfVec{{ SUFFIX }} & >())
-        .def(init< const vector< vector<float> >& >())
-        .def(init< const vector< vector<double> >& >())
+        .def(boost::python::init< const GfVec{{ SUFFIX }} & >())
+        .def(boost::python::init< const std::vector< std::vector<float> >& >())
+        .def(boost::python::init< const std::vector< std::vector<double> >& >())
 {% block customInit %}
 {% endblock customInit %}
 
@@ -325,17 +322,17 @@ void wrapMatrix{{ SUFFIX }}()
 {% endblock customSpecialMethods %}
 
         .def("Set", (This &(This::*)({{ MATRIX(SCL, indent=37) }}))&This::Set,
-             return_self<>())
+             boost::python::return_self<>())
         
-        .def("SetIdentity", &This::SetIdentity, return_self<>())
-        .def("SetZero", &This::SetZero, return_self<>())
+        .def("SetIdentity", &This::SetIdentity, boost::python::return_self<>())
+        .def("SetZero", &This::SetZero, boost::python::return_self<>())
 
         .def("SetDiagonal", 
              (This & (This::*)({{ SCL }}))&This::SetDiagonal, 
-             return_self<>())
+             boost::python::return_self<>())
         .def("SetDiagonal", 
              (This & (This::*)(const GfVec{{ SUFFIX }} &))&This::SetDiagonal, 
-             return_self<>())
+             boost::python::return_self<>())
 
         .def("SetRow", &This::SetRow)
         .def("SetColumn", &This::SetColumn)
@@ -349,35 +346,35 @@ void wrapMatrix{{ SUFFIX }}()
 {% block customDefs %}
 {% endblock customDefs %}
         
-        .def( str(self) )
-        .def( self == self )
+        .def( boost::python::self_ns::str(boost::python::self) )
+        .def( boost::python::self == boost::python::self )
 {% if SCL == 'float' %}
-        .def( self == GfMatrix{{ DIM }}d() )
+        .def( boost::python::self == GfMatrix{{ DIM }}d() )
 {% elif SCL == 'double' %}
-        .def( self == GfMatrix{{ DIM }}f() )
+        .def( boost::python::self == GfMatrix{{ DIM }}f() )
 {% endif %}
-        .def( self != self )
+        .def( boost::python::self != boost::python::self )
 {% if SCL == 'float' %}
-        .def( self != GfMatrix{{ DIM }}d() )
+        .def( boost::python::self != GfMatrix{{ DIM }}d() )
 {% elif SCL == 'double' %}
-        .def( self != GfMatrix{{ DIM }}f() )
+        .def( boost::python::self != GfMatrix{{ DIM }}f() )
 {% endif %}
-        .def( self *= self )
-        .def( self * self )
-        .def( self *= double() )
-        .def( self * double() )
-        .def( double() * self )
-        .def( self += self )
-        .def( self + self )
-        .def( self -= self )
-        .def( self - self )
-        .def( -self )
-        .def( self / self )
-        .def( self * GfVec{{ SUFFIX }}() )
-        .def( GfVec{{ SUFFIX }}() * self )
+        .def( boost::python::self *= boost::python::self )
+        .def( boost::python::self * boost::python::self )
+        .def( boost::python::self *= double() )
+        .def( boost::python::self * double() )
+        .def( double() * boost::python::self )
+        .def( boost::python::self += boost::python::self )
+        .def( boost::python::self + boost::python::self )
+        .def( boost::python::self -= boost::python::self )
+        .def( boost::python::self - boost::python::self )
+        .def( -boost::python::self )
+        .def( boost::python::self / boost::python::self )
+        .def( boost::python::self * GfVec{{ SUFFIX }}() )
+        .def( GfVec{{ SUFFIX }}() * boost::python::self )
 {% if SCL == 'double' %}
-        .def( self * GfVec{{ DIM }}f() )
-        .def( GfVec{{ DIM }}f() * self )
+        .def( boost::python::self * GfVec{{ DIM }}f() )
+        .def( GfVec{{ DIM }}f() * boost::python::self )
 {% endif %}
 
 #if PY_MAJOR_VERSION == 2
@@ -392,7 +389,7 @@ void wrapMatrix{{ SUFFIX }}()
         .def("__hash__", __hash__)
 
         ;
-    to_python_converter<std::vector<This>,
+    boost::python::to_python_converter<std::vector<This>,
         TfPySequenceToPython<std::vector<This> > >();
     
     // Install buffer protocol: set the tp_as_buffer slot to point to a
diff --git a/pxr/base/gf/wrapMatrix2d.cpp b/pxr/base/gf/wrapMatrix2d.cpp
index de100ac3e..8c544e9b6 100644
--- a/pxr/base/gf/wrapMatrix2d.cpp
+++ b/pxr/base/gf/wrapMatrix2d.cpp
@@ -67,7 +67,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfMatrix2d &mat = extract<GfMatrix2d &>(self);
+    GfMatrix2d &mat = boost::python::extract<GfMatrix2d &>(self);
     *ptrptr = static_cast<void *>(mat.GetArray());
     // Return size in bytes.
     return sizeof(GfMatrix2d);
diff --git a/pxr/base/gf/wrapMatrix2f.cpp b/pxr/base/gf/wrapMatrix2f.cpp
index 2173424c8..5adea331e 100644
--- a/pxr/base/gf/wrapMatrix2f.cpp
+++ b/pxr/base/gf/wrapMatrix2f.cpp
@@ -67,7 +67,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfMatrix2f &mat = extract<GfMatrix2f &>(self);
+    GfMatrix2f &mat = boost::python::extract<GfMatrix2f &>(self);
     *ptrptr = static_cast<void *>(mat.GetArray());
     // Return size in bytes.
     return sizeof(GfMatrix2f);
diff --git a/pxr/base/gf/wrapMatrix3.template.cpp b/pxr/base/gf/wrapMatrix3.template.cpp
index 78af10df0..44b1e218a 100644
--- a/pxr/base/gf/wrapMatrix3.template.cpp
+++ b/pxr/base/gf/wrapMatrix3.template.cpp
@@ -33,8 +33,8 @@
 {% endblock customIncludes %}
 
 {% block customInit %}
-        .def(init< const GfRotation& >())
-        .def(init< const GfQuat{{ SCL[0] }}& >())
+        .def(boost::python::init< const GfRotation& >())
+        .def(boost::python::init< const GfQuat{{ SCL[0] }}& >())
 {% endblock customInit %}
 
 {% block customDefs %}
@@ -43,20 +43,20 @@
         .def("IsRightHanded", &This::IsRightHanded)
 
         .def("Orthonormalize", &This::Orthonormalize,
-             (arg("issueWarning") = true))
+             (boost::python::arg("issueWarning") = true))
         .def("GetOrthonormalized", &This::GetOrthonormalized,
-             (arg("issueWarning") = true))
+             (boost::python::arg("issueWarning") = true))
 {% endblock customDefs %}
 
 {% block customXformDefs %}
-        .def("SetScale", (This & (This::*)( const GfVec3{{ SCL[0] }} & ))&This::SetScale, return_self<>())
+        .def("SetScale", (This & (This::*)( const GfVec3{{ SCL[0] }} & ))&This::SetScale, boost::python::return_self<>())
         .def("SetRotate",
              (This & (This::*)( const GfQuat{{ SCL[0] }} & )) &This::SetRotate,
-             return_self<>())
+             boost::python::return_self<>())
         .def("SetRotate",
              (This & (This::*)( const GfRotation & )) &This::SetRotate,
-             return_self<>())
+             boost::python::return_self<>())
         .def("ExtractRotation", &This::ExtractRotation)
-        .def("SetScale", (This & (This::*)( {{ SCL }} ))&This::SetScale, return_self<>())
+        .def("SetScale", (This & (This::*)( {{ SCL }} ))&This::SetScale, boost::python::return_self<>())
 
 {% endblock customXformDefs %}
diff --git a/pxr/base/gf/wrapMatrix3d.cpp b/pxr/base/gf/wrapMatrix3d.cpp
index 7c8165b95..a739c5488 100644
--- a/pxr/base/gf/wrapMatrix3d.cpp
+++ b/pxr/base/gf/wrapMatrix3d.cpp
@@ -70,7 +70,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfMatrix3d &mat = extract<GfMatrix3d &>(self);
+    GfMatrix3d &mat = boost::python::extract<GfMatrix3d &>(self);
     *ptrptr = static_cast<void *>(mat.GetArray());
     // Return size in bytes.
     return sizeof(GfMatrix3d);
diff --git a/pxr/base/gf/wrapMatrix3f.cpp b/pxr/base/gf/wrapMatrix3f.cpp
index 60bb801b3..dcfbc9f85 100644
--- a/pxr/base/gf/wrapMatrix3f.cpp
+++ b/pxr/base/gf/wrapMatrix3f.cpp
@@ -70,7 +70,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfMatrix3f &mat = extract<GfMatrix3f &>(self);
+    GfMatrix3f &mat = boost::python::extract<GfMatrix3f &>(self);
     *ptrptr = static_cast<void *>(mat.GetArray());
     // Return size in bytes.
     return sizeof(GfMatrix3f);
diff --git a/pxr/base/gf/wrapMatrix4.template.cpp b/pxr/base/gf/wrapMatrix4.template.cpp
index fad048b07..f87b6d984 100644
--- a/pxr/base/gf/wrapMatrix4.template.cpp
+++ b/pxr/base/gf/wrapMatrix4.template.cpp
@@ -37,14 +37,14 @@
 {% endblock customIncludes %}
 
 {% block customFunctions %}
-static tuple FactorWithEpsilon({{ MAT }} &self, double eps) {
+static boost::python::tuple FactorWithEpsilon({{ MAT }} &self, double eps) {
     {{ MAT }} r, u, p;
     GfVec3{{ SCL[0] }} s, t;
     bool result = self.Factor(&r, &s, &u, &t, &p, eps);
     return boost::python::make_tuple(result, r, s, u, t, p);
 }    
 
-static tuple Factor({{ MAT }} &self) {
+static boost::python::tuple Factor({{ MAT }} &self) {
     {{ MAT }} r, u, p;
     GfVec3{{ SCL[0] }} s, t;
     bool result = self.Factor(&r, &s, &u, &t, &p);
@@ -57,16 +57,16 @@ static {{ MAT }} RemoveScaleShearWrapper( const {{ MAT }} &self ) {
 {% endblock customFunctions %}
 
 {% block customInit %}
-        .def(init< const vector<float>&,
-                   const vector<float>&,
-                   const vector<float>&,
-                   const vector<float>& >())
-        .def(init< const vector<double>&,
-                   const vector<double>&,
-                   const vector<double>&,
-                   const vector<double>& >())
-        .def(init< const GfMatrix3{{ SCL[0] }} &, const GfVec3{{ SCL[0] }} >())
-        .def(init< const GfRotation &, const GfVec3{{ SCL[0] }} >())
+        .def(boost::python::init< const std::vector<float>&,
+                   const std::vector<float>&,
+                   const std::vector<float>&,
+                   const std::vector<float>& >())
+        .def(boost::python::init< const std::vector<double>&,
+                   const std::vector<double>&,
+                   const std::vector<double>&,
+                   const std::vector<double>& >())
+        .def(boost::python::init< const GfMatrix3{{ SCL[0] }} &, const GfVec3{{ SCL[0] }} >())
+        .def(boost::python::init< const GfRotation &, const GfVec3{{ SCL[0] }} >())
 {% endblock customInit %}
 
 {% block customDefs %}
@@ -80,57 +80,57 @@ static {{ MAT }} RemoveScaleShearWrapper( const {{ MAT }} &self ) {
         .def("IsRightHanded", &This::IsRightHanded)
 
         .def("Orthonormalize", &This::Orthonormalize,
-             (arg("issueWarning") = true))
+             (boost::python::arg("issueWarning") = true))
         .def("GetOrthonormalized", &This::GetOrthonormalized,
-             (arg("issueWarning") = true))
+             (boost::python::arg("issueWarning") = true))
 {% endblock customDefs %}
 
 {% block customXformDefs %}
         .def("SetTransform",
 	     (This & (This::*)( const GfRotation &,
 				const GfVec3{{ SCL[0] }} & ))&This::SetTransform,
-	     return_self<>())	
+	     boost::python::return_self<>())	
         .def("SetTransform",
 	     (This & (This::*)( const GfMatrix3{{ SCL[0] }}&,
 				const GfVec3{{ SCL[0] }} & ))&This::SetTransform,
-	     return_self<>())
+	     boost::python::return_self<>())
 
         .def("SetScale", (This & (This::*)( const GfVec3{{ SCL[0] }}& ))&This::SetScale,
-	     return_self<>())
+	     boost::python::return_self<>())
 
-        .def("SetTranslate", &This::SetTranslate, return_self<>())
-        .def("SetTranslateOnly", &This::SetTranslateOnly, return_self<>())
+        .def("SetTranslate", &This::SetTranslate, boost::python::return_self<>())
+        .def("SetTranslateOnly", &This::SetTranslateOnly, boost::python::return_self<>())
 
         .def("SetRotate",
 	     (This & (This::*)( const GfQuat{{ SCL[0] }} & )) &This::SetRotate,
-	     return_self<>())
+	     boost::python::return_self<>())
         .def("SetRotateOnly",
 	     (This & (This::*)( const GfQuat{{ SCL[0] }} & )) &This::SetRotateOnly,
-	     return_self<>())
+	     boost::python::return_self<>())
 
         .def("SetRotate",
 	     (This & (This::*)( const GfRotation & )) &This::SetRotate,
-	     return_self<>())
+	     boost::python::return_self<>())
         .def("SetRotateOnly",
 	     (This & (This::*)( const GfRotation & )) &This::SetRotateOnly,
-	     return_self<>())
+	     boost::python::return_self<>())
 
         .def("SetRotate",
 	     (This & (This::*)( const GfMatrix3{{ SCL[0] }}& )) &This::SetRotate,
-	     return_self<>())
+	     boost::python::return_self<>())
         .def("SetRotateOnly",
 	     (This & (This::*)( const GfMatrix3{{ SCL[0] }}& )) &This::SetRotateOnly,
-	     return_self<>())
+	     boost::python::return_self<>())
 
         .def("SetLookAt", (This & (This::*)( const GfVec3{{ SCL[0] }} &,
                                              const GfVec3{{ SCL[0] }} &,
                                              const GfVec3{{ SCL[0] }} & ))&This::SetLookAt,
-	     return_self<>())
+	     boost::python::return_self<>())
 
         .def("SetLookAt",
              (This & (This::*)( const GfVec3{{ SCL[0] }} &,
                                 const GfRotation & ))&This::SetLookAt,
-             return_self<>())
+             boost::python::return_self<>())
 
         .def("ExtractTranslation", &This::ExtractTranslation)
         .def("ExtractRotation", &This::ExtractRotation)
@@ -156,6 +156,6 @@ static {{ MAT }} RemoveScaleShearWrapper( const {{ MAT }} &self ) {
         .def("TransformAffine",
 	     (GfVec3d (This::*)(const GfVec3d &) const)&This::TransformAffine)
         .def("SetScale", (This & (This::*)( {{ SCL }} ))&This::SetScale,
-	     return_self<>())
+	     boost::python::return_self<>())
 
 {% endblock customXformDefs %}
diff --git a/pxr/base/gf/wrapMatrix4d.cpp b/pxr/base/gf/wrapMatrix4d.cpp
index 91c5ce9d1..0680eb6a4 100644
--- a/pxr/base/gf/wrapMatrix4d.cpp
+++ b/pxr/base/gf/wrapMatrix4d.cpp
@@ -74,7 +74,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfMatrix4d &mat = extract<GfMatrix4d &>(self);
+    GfMatrix4d &mat = boost::python::extract<GfMatrix4d &>(self);
     *ptrptr = static_cast<void *>(mat.GetArray());
     // Return size in bytes.
     return sizeof(GfMatrix4d);
diff --git a/pxr/base/gf/wrapMatrix4f.cpp b/pxr/base/gf/wrapMatrix4f.cpp
index b3b5c9aa3..6acacda10 100644
--- a/pxr/base/gf/wrapMatrix4f.cpp
+++ b/pxr/base/gf/wrapMatrix4f.cpp
@@ -74,7 +74,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfMatrix4f &mat = extract<GfMatrix4f &>(self);
+    GfMatrix4f &mat = boost::python::extract<GfMatrix4f &>(self);
     *ptrptr = static_cast<void *>(mat.GetArray());
     // Return size in bytes.
     return sizeof(GfMatrix4f);
diff --git a/pxr/base/gf/wrapQuat.template.cpp b/pxr/base/gf/wrapQuat.template.cpp
index b9102ee20..2151d1ea0 100644
--- a/pxr/base/gf/wrapQuat.template.cpp
+++ b/pxr/base/gf/wrapQuat.template.cpp
@@ -45,15 +45,13 @@
 
 #include <string>
 
-using namespace boost::python;
 
-using std::string;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
 namespace {
 
-static string __repr__({{ QUAT }} const &self) {
+static std::string __repr__({{ QUAT }} const &self) {
     return TF_PY_REPR_PREFIX + "Quat{{ SUFFIX }}(" +
         TfPyRepr(self.GetReal()) + ", " +
         TfPyRepr(self.GetImaginary()) + ")";
@@ -78,41 +76,41 @@ static {{ QUAT }} *__init__() { return new {{ QUAT }}(0); }
 
 void wrapQuat{{ SUFFIX }}()
 {    
-    object getImaginary =
-        make_function(&{{ QUAT }}::GetImaginary,
-                      return_value_policy<return_by_value>());
+    boost::python::object getImaginary =
+        boost::python::make_function(&{{ QUAT }}::GetImaginary,
+                      boost::python::return_value_policy<boost::python::return_by_value>());
 
-    object setImaginaryVec =
-        make_function((void ({{ QUAT }}::*)(const GfVec3{{ SUFFIX }} &))
+    boost::python::object setImaginaryVec =
+        boost::python::make_function((void ({{ QUAT }}::*)(const GfVec3{{ SUFFIX }} &))
                       &{{ QUAT }}::SetImaginary);
 
-    object setImaginaryScl =
-        make_function((void ({{ QUAT }}::*)({{ SCL }}, {{ SCL }}, {{ SCL }}))
+    boost::python::object setImaginaryScl =
+        boost::python::make_function((void ({{ QUAT }}::*)({{ SCL }}, {{ SCL }}, {{ SCL }}))
                       &{{ QUAT }}::SetImaginary,
-                      default_call_policies(),
-                      (arg("i"), arg("j"), arg("k")));
+                      boost::python::default_call_policies(),
+                      (boost::python::arg("i"), boost::python::arg("j"), boost::python::arg("k")));
 
-    def("Slerp",
+    boost::python::def("Slerp",
         ({{ QUAT }} (*)(double, const {{ QUAT }}&, const {{ QUAT }}&))
         GfSlerp);
 
-    def("Dot",
+    boost::python::def("Dot",
         ({{ SCL }} (*)(const {{ QUAT }}&, const {{ QUAT }}&))
         GfDot);
     
-    class_<{{ QUAT }}>("Quat{{ SUFFIX }}", no_init)
-        .def("__init__", make_constructor(__init__))
+    boost::python::class_<{{ QUAT }}>("Quat{{ SUFFIX }}", boost::python::no_init)
+        .def("__init__", boost::python::make_constructor(__init__))
                           
         .def(TfTypePythonClass())
 
-        .def(init<GfQuat{{ SUFFIX }}>())
-        .def(init<{{ SCL }}>(arg("real")))
-        .def(init<{{ SCL }}, const GfVec3{{ SUFFIX }} &>(
-                 (arg("real"), arg("imaginary"))))
-        .def(init<{{ SCL }}, {{ SCL }}, {{ SCL }}, {{ SCL }}>(
-                 (arg("real"), arg("i"), arg("j"), arg("k"))))
+        .def(boost::python::init<GfQuat{{ SUFFIX }}>())
+        .def(boost::python::init<{{ SCL }}>(boost::python::arg("real")))
+        .def(boost::python::init<{{ SCL }}, const GfVec3{{ SUFFIX }} &>(
+                 (boost::python::arg("real"), boost::python::arg("imaginary"))))
+        .def(boost::python::init<{{ SCL }}, {{ SCL }}, {{ SCL }}, {{ SCL }}>(
+                 (boost::python::arg("real"), boost::python::arg("i"), boost::python::arg("j"), boost::python::arg("k"))))
 {% for S in SCALARS if S != SCL and not ALLOW_IMPLICIT_CONVERSION(S, SCL) %}
-        .def(init<const GfQuat{{ SCALAR_SUFFIX(S) }} & >())
+        .def(boost::python::init<const GfQuat{{ SCALAR_SUFFIX(S) }} & >())
 {% endfor %}
 
         .def("GetIdentity", &{{ QUAT }}::GetIdentity)
@@ -130,30 +128,30 @@ void wrapQuat{{ SUFFIX }}()
         .def("GetLength", &{{ QUAT }}::GetLength)
 
         .def("GetNormalized", &{{ QUAT }}::GetNormalized,
-             (arg("eps")=GF_MIN_VECTOR_LENGTH))
+             (boost::python::arg("eps")=GF_MIN_VECTOR_LENGTH))
         .def("Normalize", &{{ QUAT }}::Normalize,
-             (arg("eps")=GF_MIN_VECTOR_LENGTH), return_self<>())
+             (boost::python::arg("eps")=GF_MIN_VECTOR_LENGTH), boost::python::return_self<>())
 
         .def("GetConjugate", &{{ QUAT }}::GetConjugate)
         .def("GetInverse", &{{ QUAT }}::GetInverse)
 
         .def("Transform", &{{ QUAT }}::Transform)
 
-        .def(str(self))
-        .def(-self)
-        .def(self == self)
-        .def(self != self)
-        .def(self *= self)
-        .def(self *= {{ SCL }}())
-        .def(self /= {{ SCL }}())
-        .def(self += self)
-        .def(self -= self)
-        .def(self + self)
-        .def(self - self)
-        .def(self * self)
-        .def(self * {{ SCL }}())
-        .def({{ SCL }}() * self)
-        .def(self / {{ SCL }}())
+        .def(boost::python::self_ns::str(boost::python::self))
+        .def(-boost::python::self)
+        .def(boost::python::self == boost::python::self)
+        .def(boost::python::self != boost::python::self)
+        .def(boost::python::self *= boost::python::self)
+        .def(boost::python::self *= {{ SCL }}())
+        .def(boost::python::self /= {{ SCL }}())
+        .def(boost::python::self += boost::python::self)
+        .def(boost::python::self -= boost::python::self)
+        .def(boost::python::self + boost::python::self)
+        .def(boost::python::self - boost::python::self)
+        .def(boost::python::self * boost::python::self)
+        .def(boost::python::self * {{ SCL }}())
+        .def({{ SCL }}() * boost::python::self)
+        .def(boost::python::self / {{ SCL }}())
 
 #if PY_MAJOR_VERSION == 2
         // Needed only to support "from __future__ import division" in
@@ -167,10 +165,10 @@ void wrapQuat{{ SUFFIX }}()
         ;
 
 {% for S in SCALARS if S != SCL and ALLOW_IMPLICIT_CONVERSION(S, SCL) %}
-    implicitly_convertible<{{ QUATNAME(S) }}, {{ QUAT }}>();
+    boost::python::implicitly_convertible<{{ QUATNAME(S) }}, {{ QUAT }}>();
 {% endfor %}
 
-    to_python_converter<std::vector<{{ QUAT }}>,
+    boost::python::to_python_converter<std::vector<{{ QUAT }}>,
         TfPySequenceToPython<std::vector<{{ QUAT }}> > >();
     
 }
diff --git a/pxr/base/gf/wrapRange.template.cpp b/pxr/base/gf/wrapRange.template.cpp
index 6695646ec..cc235bc0c 100644
--- a/pxr/base/gf/wrapRange.template.cpp
+++ b/pxr/base/gf/wrapRange.template.cpp
@@ -42,9 +42,7 @@
 
 #include <string>
 
-using namespace boost::python;
 
-using std::string;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -52,7 +50,7 @@ namespace {
 
 static const int _dimension = {{ DIM }};
 
-static string _Repr({{ RNG }} const &self) {
+static std::string _Repr({{ RNG }} const &self) {
     return TF_PY_REPR_PREFIX + "Range{{ SUFFIX }}(" +
         TfPyRepr(self.GetMin()) + ", " + TfPyRepr(self.GetMax()) + ")";
 }
@@ -75,15 +73,15 @@ static size_t __hash__({{ RNG }} const &r) { return hash_value(r); }
 
 void wrapRange{{ SUFFIX }}()
 {    
-    object getMin = make_function(&{{ RNG }}::GetMin,
-                                  return_value_policy<return_by_value>());
+    boost::python::object getMin = boost::python::make_function(&{{ RNG }}::GetMin,
+                                  boost::python::return_value_policy<boost::python::return_by_value>());
 
-    object getMax = make_function(&{{ RNG }}::GetMax,
-                                  return_value_policy<return_by_value>());
+    boost::python::object getMax = boost::python::make_function(&{{ RNG }}::GetMax,
+                                  boost::python::return_value_policy<boost::python::return_by_value>());
 
-    class_<{{ RNG }}>("Range{{ SUFFIX }}", init<>())
-        .def(init<{{ RNG }}>())
-        .def(init<{{ MINMAXPARM }}, {{ MINMAXPARM }}>())
+    boost::python::class_<{{ RNG }}>("Range{{ SUFFIX }}", boost::python::init<>())
+        .def(boost::python::init<{{ RNG }}>())
+        .def(boost::python::init<{{ MINMAXPARM }}, {{ MINMAXPARM }}>())
         
         .def(TfTypePythonClass())
 
@@ -114,34 +112,34 @@ void wrapRange{{ SUFFIX }}()
         .staticmethod("GetUnion")
     
         .def("UnionWith", (const {{ RNG }} & ({{ RNG }}::*)({{ MINMAXPARM }}))
-             &{{ RNG }}::UnionWith, return_self<>())
+             &{{ RNG }}::UnionWith, boost::python::return_self<>())
         .def("UnionWith", (const {{ RNG }} & ({{ RNG }}::*)(const {{ RNG }} &))
-             &{{ RNG }}::UnionWith, return_self<>())
+             &{{ RNG }}::UnionWith, boost::python::return_self<>())
     
         .def("GetIntersection", &{{ RNG }}::GetIntersection)
         .staticmethod("GetIntersection")
     
         .def("IntersectWith", (const {{ RNG }} & ({{ RNG }}::*)(const {{ RNG }} &))
-             &{{ RNG }}::IntersectWith, return_self<>())
+             &{{ RNG }}::IntersectWith, boost::python::return_self<>())
     
         .def("GetDistanceSquared", &{{ RNG }}::GetDistanceSquared)
     
-        .def(str(self))
-        .def(self += self)
-        .def(self -= self)
-        .def(self *= double())
-        .def(self /= double())
-        .def(self + self)
-        .def(self - self)
-        .def(double() * self)
-        .def(self * double())
-        .def(self / double())
+        .def(boost::python::self_ns::str(boost::python::self))
+        .def(boost::python::self += boost::python::self)
+        .def(boost::python::self -= boost::python::self)
+        .def(boost::python::self *= double())
+        .def(boost::python::self /= double())
+        .def(boost::python::self + boost::python::self)
+        .def(boost::python::self - boost::python::self)
+        .def(double() * boost::python::self)
+        .def(boost::python::self * double())
+        .def(boost::python::self / double())
 {% for S in SCALARS if S != SCL %}
-        .def(self == {{ RNGNAME(DIM, S) }}())
-        .def(self != {{ RNGNAME(DIM, S) }}())
+        .def(boost::python::self == {{ RNGNAME(DIM, S) }}())
+        .def(boost::python::self != {{ RNGNAME(DIM, S) }}())
 {% endfor %}
-        .def(self == self)
-        .def(self != self)
+        .def(boost::python::self == boost::python::self)
+        .def(boost::python::self != boost::python::self)
     
 #if PY_MAJOR_VERSION == 2
         // Needed only to support "from __future__ import division" in
@@ -164,7 +162,7 @@ void wrapRange{{ SUFFIX }}()
 {% endif %}
         
         ;
-    to_python_converter<std::vector<{{ RNG }}>,
+    boost::python::to_python_converter<std::vector<{{ RNG }}>,
         TfPySequenceToPython<std::vector<{{ RNG }}> > >();
     
 }
diff --git a/pxr/base/gf/wrapVec.template.cpp b/pxr/base/gf/wrapVec.template.cpp
index 5c102a8d2..1d43180c2 100644
--- a/pxr/base/gf/wrapVec.template.cpp
+++ b/pxr/base/gf/wrapVec.template.cpp
@@ -56,9 +56,7 @@
 
 #include <string>
 
-using namespace boost::python;
 
-using std::string;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -76,7 +74,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    {{ VEC }} &vec = extract<{{ VEC }} &>(self);
+    {{ VEC }} &vec = boost::python::extract<{{ VEC }} &>(self);
     *ptrptr = static_cast<void *>(vec.data());
     // Return size in bytes.
     return sizeof({{ VEC }});
@@ -120,7 +118,7 @@ getbuffer(PyObject *self, Py_buffer *view, int flags) {
         return -1;
     }
 
-    {{ VEC }} &vec = extract<{{ VEC }} &>(self);
+    {{ VEC }} &vec = boost::python::extract<{{ VEC }} &>(self);
 
     view->obj = self;
     view->buf = static_cast<void *>(vec.data());
@@ -170,8 +168,8 @@ static PyBufferProcs bufferProcs = {
 ////////////////////////////////////////////////////////////////////////
 
 
-static string __repr__({{ VEC }} const &self) {
-    string elems;
+static std::string __repr__({{ VEC }} const &self) {
+    std::string elems;
     for (size_t i = 0; i < self.dimension; ++i) 
         elems += (i ? ", " : "") + TfPyRepr(self[i]);
 
@@ -213,7 +211,7 @@ OrthogonalizeBasisHelper( {{ VEC }} *v1, {{ VEC }} *v2, {{ VEC }} *v3,
 BOOST_PYTHON_FUNCTION_OVERLOADS(OrthogonalizeBasis_overloads,
                                 OrthogonalizeBasisHelper, 4, 5)
 
-static tuple
+static boost::python::tuple
 BuildOrthonormalFrameHelper(const {{ VEC }} &self,
                             double eps = {{ EPS }})
 {
@@ -240,13 +238,13 @@ static {{ SCL }} __getitem__(const {{ VEC }} &self, int index) {
 }
 
 // Implements __getitem__ for a slice
-static list __getslice__(const {{ VEC }} &self, slice indices) {
-    list result;
+static boost::python::list __getslice__(const {{ VEC }} &self, boost::python::slice indices) {
+    boost::python::list result;
 
     const {{ SCL }}* begin = self.data();
     const {{ SCL }}* end = begin + {{ DIM }};
 
-    slice::range<const {{ SCL }}*> bounds;
+    boost::python::slice::range<const {{ SCL }}*> bounds;
     try {
         // This appears to be a typo in the boost headers.  The method
         // name should be "get_indices".
@@ -276,16 +274,16 @@ static void __setitem__({{ VEC }} &self, int index, {{ SCL }} value) {
 // Handles refcounting & extraction for PySequence_GetItem.
 static {{ SCL }} _SequenceGetItem(PyObject *seq, Py_ssize_t i) {
     boost::python::handle<> h(PySequence_GetItem(seq, i));
-    return extract<{{ SCL }}>(boost::python::object(h));
+    return boost::python::extract<{{ SCL }}>(boost::python::object(h));
 }
 
 static bool _SequenceCheckItem(PyObject *seq, Py_ssize_t i) {
     boost::python::handle<> h(PySequence_GetItem(seq, i));
-    extract<{{ SCL }}> e((boost::python::object(h)));
+    boost::python::extract<{{ SCL }}> e((boost::python::object(h)));
     return e.check();
 }
 
-static void __setslice__({{ VEC }} &self, slice indices, object values) {
+static void __setslice__({{ VEC }} &self, boost::python::slice indices, boost::python::object values) {
     // Verify our arguments
     //
     PyObject* valuesObj = values.ptr();
@@ -299,7 +297,7 @@ static void __setslice__({{ VEC }} &self, slice indices, object values) {
 
     Py_ssize_t sliceLength = -1;
 
-    slice::range<{{ SCL }}*> bounds;
+    boost::python::slice::range<{{ SCL }}*> bounds;
 
     // Convince g++ that we're not using uninitialized values.
     //
@@ -377,7 +375,7 @@ static V *__init__() {
 
 struct FromPythonTuple {
     FromPythonTuple() {
-        converter::registry::
+        boost::python::converter::registry::
             push_back(&_convertible, &_construct,
                       boost::python::type_id<{{ VEC }}>());
     }
@@ -402,10 +400,10 @@ struct FromPythonTuple {
         return 0;
     }
 
-    static void _construct(PyObject *obj_ptr, converter::
+    static void _construct(PyObject *obj_ptr, boost::python::converter::
                            rvalue_from_python_stage1_data *data) {
         typedef {{ SCL }} Scalar;
-        void *storage = ((converter::rvalue_from_python_storage<{{ VEC }}>*)data)
+        void *storage = ((boost::python::converter::rvalue_from_python_storage<{{ VEC }}>*)data)
 	    ->storage.bytes;
         new (storage)
 	    {{ VEC }}(
@@ -435,33 +433,33 @@ void wrapVec{{ SUFFIX }}()
     static const size_t _dimension = {{ DIM }};
     static const bool _true = true;
     
-    def("Dot", (Scalar (*)( const Vec &, const Vec &))GfDot);
+    boost::python::def("Dot", (Scalar (*)( const Vec &, const Vec &))GfDot);
     
 {% if IS_FLOATING_POINT(SCL) %}
-    def("CompDiv", (Vec (*)(const Vec &v1, const Vec&v2))GfCompDiv);
-    def("CompMult", (Vec (*)(const Vec &v1, const Vec&v2))GfCompMult);
-    def("GetLength", (Scalar (*)(const Vec &v))GfGetLength);
-    def("GetNormalized", (Vec (*)(const Vec &v, Scalar eps))
+    boost::python::def("CompDiv", (Vec (*)(const Vec &v1, const Vec&v2))GfCompDiv);
+    boost::python::def("CompMult", (Vec (*)(const Vec &v1, const Vec&v2))GfCompMult);
+    boost::python::def("GetLength", (Scalar (*)(const Vec &v))GfGetLength);
+    boost::python::def("GetNormalized", (Vec (*)(const Vec &v, Scalar eps))
         GfGetNormalized, GetNormalized_overloads());
-    def("GetProjection", (Vec (*)(const Vec &a, const Vec &b))
+    boost::python::def("GetProjection", (Vec (*)(const Vec &a, const Vec &b))
         GfGetProjection);
-    def("GetComplement", (Vec (*)(const Vec &a, const Vec &b))
+    boost::python::def("GetComplement", (Vec (*)(const Vec &a, const Vec &b))
         GfGetComplement);
-    def("IsClose", (bool (*)(const Vec &v1, const Vec &v2, double))
+    boost::python::def("IsClose", (bool (*)(const Vec &v1, const Vec &v2, double))
         GfIsClose);
-    def("Normalize", NormalizeHelper, Normalize_overloads());
+    boost::python::def("Normalize", NormalizeHelper, Normalize_overloads());
         
 {% if DIM == 3 %}
-    def("Cross", (Vec (*)(const Vec &v1, const Vec &v2))GfCross);
-    def("Slerp", (Vec (*)(double alpha, const Vec &v0, const Vec &v1))
+    boost::python::def("Cross", (Vec (*)(const Vec &v1, const Vec &v2))GfCross);
+    boost::python::def("Slerp", (Vec (*)(double alpha, const Vec &v0, const Vec &v1))
         GfSlerp);
 {% endif %}
 
 {% endif %} {# IS_FLOATING_POINT(SCL) #}
 
-    class_<{{ VEC }}> cls("Vec{{ SUFFIX }}", no_init);
+    boost::python::class_<{{ VEC }}> cls("Vec{{ SUFFIX }}", boost::python::no_init);
     cls
-        .def("__init__", make_constructor(__init__<Vec>))
+        .def("__init__", boost::python::make_constructor(__init__<Vec>))
 
         // A tag indicating that this is a GfVec class, for internal use.
         .def_readonly("__isGfVec", _true)
@@ -471,13 +469,13 @@ void wrapVec{{ SUFFIX }}()
 {% if IS_FLOATING_POINT(SCL) %}
         // Conversion from other vec types.
 {% for S in SCALARS if S != SCL %}
-        .def(init<{{ VECNAME(DIM, S) }}>())
+        .def(boost::python::init<{{ VECNAME(DIM, S) }}>())
 {% endfor %}
 {% endif %}
         
-        .def(init<Vec>())
-        .def(init<Scalar>())
-        .def(init<{{ LIST("Scalar") }}>())
+        .def(boost::python::init<Vec>())
+        .def(boost::python::init<Scalar>())
+        .def(boost::python::init<{{ LIST("Scalar") }}>())
 
         .def(TfTypePythonClass())
 
@@ -493,25 +491,25 @@ void wrapVec{{ SUFFIX }}()
 {% if IS_FLOATING_POINT(SCL) %}
         // Comparison to other vec types.
 {% for S in SCALARS if S != SCL and ALLOW_IMPLICIT_CONVERSION(S, SCL) %}
-        .def( self == {{ VECNAME(DIM, S) }}() )
-        .def( self != {{ VECNAME(DIM, S) }}() )
+        .def( boost::python::self == {{ VECNAME(DIM, S) }}() )
+        .def( boost::python::self != {{ VECNAME(DIM, S) }}() )
 {% endfor %}
 {% endif %}
 
-        .def(self == self)
-        .def(self != self)
-        .def(self += self)
-        .def(self -= self)
-        .def(self *= double())
-        .def(self * double())
-        .def(double() * self)
-        .def(self /= {{ SCL }}())
-        .def(self / {{ SCL }}())
-        .def(-self)
-        .def(self + self)
-        .def(self - self)
-        .def(self * self)
-        .def(str(self))
+        .def(boost::python::self == boost::python::self)
+        .def(boost::python::self != boost::python::self)
+        .def(boost::python::self += boost::python::self)
+        .def(boost::python::self -= boost::python::self)
+        .def(boost::python::self *= double())
+        .def(boost::python::self * double())
+        .def(double() * boost::python::self)
+        .def(boost::python::self /= {{ SCL }}())
+        .def(boost::python::self / {{ SCL }}())
+        .def(-boost::python::self)
+        .def(boost::python::self + boost::python::self)
+        .def(boost::python::self - boost::python::self)
+        .def(boost::python::self * boost::python::self)
+        .def(boost::python::self_ns::str(boost::python::self))
 
 #if PY_MAJOR_VERSION == 2
         // Needed only to support "from __future__ import division" in
@@ -535,7 +533,7 @@ void wrapVec{{ SUFFIX }}()
         .def("GetProjection", &Vec::GetProjection)
         .def("Normalize", &Vec::Normalize, VecNormalize_overloads())
 {% if DIM == 3 %}
-        .def(self ^ self)
+        .def(boost::python::self ^ boost::python::self)
         .def("GetCross", (Vec (*)(const Vec &v1, const Vec &v2))GfCross)
         .def("OrthogonalizeBasis",
              OrthogonalizeBasisHelper, OrthogonalizeBasis_overloads())
@@ -549,7 +547,7 @@ void wrapVec{{ SUFFIX }}()
         .def("__repr__", __repr__)
         .def("__hash__", __hash__)
         ;
-    to_python_converter<std::vector<{{ VEC }}>,
+    boost::python::to_python_converter<std::vector<{{ VEC }}>,
         TfPySequenceToPython<std::vector<{{ VEC }}> > >();
 
     // Install buffer protocol: set the tp_as_buffer slot to point to a
diff --git a/pxr/base/gf/wrapVec2d.cpp b/pxr/base/gf/wrapVec2d.cpp
index 4c8b27f07..c7c37cff9 100644
--- a/pxr/base/gf/wrapVec2d.cpp
+++ b/pxr/base/gf/wrapVec2d.cpp
@@ -72,7 +72,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfVec2d &vec = extract<GfVec2d &>(self);
+    GfVec2d &vec = boost::python::extract<GfVec2d &>(self);
     *ptrptr = static_cast<void *>(vec.data());
     // Return size in bytes.
     return sizeof(GfVec2d);
diff --git a/pxr/base/gf/wrapVec2f.cpp b/pxr/base/gf/wrapVec2f.cpp
index f33327696..8ac82a098 100644
--- a/pxr/base/gf/wrapVec2f.cpp
+++ b/pxr/base/gf/wrapVec2f.cpp
@@ -72,7 +72,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfVec2f &vec = extract<GfVec2f &>(self);
+    GfVec2f &vec = boost::python::extract<GfVec2f &>(self);
     *ptrptr = static_cast<void *>(vec.data());
     // Return size in bytes.
     return sizeof(GfVec2f);
diff --git a/pxr/base/gf/wrapVec2h.cpp b/pxr/base/gf/wrapVec2h.cpp
index e70483e03..c1b0b1e37 100644
--- a/pxr/base/gf/wrapVec2h.cpp
+++ b/pxr/base/gf/wrapVec2h.cpp
@@ -72,7 +72,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfVec2h &vec = extract<GfVec2h &>(self);
+    GfVec2h &vec = boost::python::extract<GfVec2h &>(self);
     *ptrptr = static_cast<void *>(vec.data());
     // Return size in bytes.
     return sizeof(GfVec2h);
diff --git a/pxr/base/gf/wrapVec2i.cpp b/pxr/base/gf/wrapVec2i.cpp
index e1f0d70cc..8af08e4e1 100644
--- a/pxr/base/gf/wrapVec2i.cpp
+++ b/pxr/base/gf/wrapVec2i.cpp
@@ -67,7 +67,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfVec2i &vec = extract<GfVec2i &>(self);
+    GfVec2i &vec = boost::python::extract<GfVec2i &>(self);
     *ptrptr = static_cast<void *>(vec.data());
     // Return size in bytes.
     return sizeof(GfVec2i);
diff --git a/pxr/base/gf/wrapVec3d.cpp b/pxr/base/gf/wrapVec3d.cpp
index 01f9c5165..3b65f3f47 100644
--- a/pxr/base/gf/wrapVec3d.cpp
+++ b/pxr/base/gf/wrapVec3d.cpp
@@ -72,7 +72,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfVec3d &vec = extract<GfVec3d &>(self);
+    GfVec3d &vec = boost::python::extract<GfVec3d &>(self);
     *ptrptr = static_cast<void *>(vec.data());
     // Return size in bytes.
     return sizeof(GfVec3d);
diff --git a/pxr/base/gf/wrapVec3f.cpp b/pxr/base/gf/wrapVec3f.cpp
index a685c03f5..a2b7b0ed0 100644
--- a/pxr/base/gf/wrapVec3f.cpp
+++ b/pxr/base/gf/wrapVec3f.cpp
@@ -72,7 +72,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfVec3f &vec = extract<GfVec3f &>(self);
+    GfVec3f &vec = boost::python::extract<GfVec3f &>(self);
     *ptrptr = static_cast<void *>(vec.data());
     // Return size in bytes.
     return sizeof(GfVec3f);
diff --git a/pxr/base/gf/wrapVec3h.cpp b/pxr/base/gf/wrapVec3h.cpp
index 92a063cd4..d85730f64 100644
--- a/pxr/base/gf/wrapVec3h.cpp
+++ b/pxr/base/gf/wrapVec3h.cpp
@@ -72,7 +72,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfVec3h &vec = extract<GfVec3h &>(self);
+    GfVec3h &vec = boost::python::extract<GfVec3h &>(self);
     *ptrptr = static_cast<void *>(vec.data());
     // Return size in bytes.
     return sizeof(GfVec3h);
diff --git a/pxr/base/gf/wrapVec3i.cpp b/pxr/base/gf/wrapVec3i.cpp
index e6fac9375..23f0bbe1f 100644
--- a/pxr/base/gf/wrapVec3i.cpp
+++ b/pxr/base/gf/wrapVec3i.cpp
@@ -67,7 +67,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfVec3i &vec = extract<GfVec3i &>(self);
+    GfVec3i &vec = boost::python::extract<GfVec3i &>(self);
     *ptrptr = static_cast<void *>(vec.data());
     // Return size in bytes.
     return sizeof(GfVec3i);
diff --git a/pxr/base/gf/wrapVec4d.cpp b/pxr/base/gf/wrapVec4d.cpp
index b81f566d3..cde4051ed 100644
--- a/pxr/base/gf/wrapVec4d.cpp
+++ b/pxr/base/gf/wrapVec4d.cpp
@@ -72,7 +72,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfVec4d &vec = extract<GfVec4d &>(self);
+    GfVec4d &vec = boost::python::extract<GfVec4d &>(self);
     *ptrptr = static_cast<void *>(vec.data());
     // Return size in bytes.
     return sizeof(GfVec4d);
diff --git a/pxr/base/gf/wrapVec4f.cpp b/pxr/base/gf/wrapVec4f.cpp
index d5c94233f..50850c66a 100644
--- a/pxr/base/gf/wrapVec4f.cpp
+++ b/pxr/base/gf/wrapVec4f.cpp
@@ -72,7 +72,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfVec4f &vec = extract<GfVec4f &>(self);
+    GfVec4f &vec = boost::python::extract<GfVec4f &>(self);
     *ptrptr = static_cast<void *>(vec.data());
     // Return size in bytes.
     return sizeof(GfVec4f);
diff --git a/pxr/base/gf/wrapVec4h.cpp b/pxr/base/gf/wrapVec4h.cpp
index fe3d4f33e..2ec0863c4 100644
--- a/pxr/base/gf/wrapVec4h.cpp
+++ b/pxr/base/gf/wrapVec4h.cpp
@@ -72,7 +72,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfVec4h &vec = extract<GfVec4h &>(self);
+    GfVec4h &vec = boost::python::extract<GfVec4h &>(self);
     *ptrptr = static_cast<void *>(vec.data());
     // Return size in bytes.
     return sizeof(GfVec4h);
diff --git a/pxr/base/gf/wrapVec4i.cpp b/pxr/base/gf/wrapVec4i.cpp
index a82b3318e..e3d6469c3 100644
--- a/pxr/base/gf/wrapVec4i.cpp
+++ b/pxr/base/gf/wrapVec4i.cpp
@@ -67,7 +67,7 @@ getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    GfVec4i &vec = extract<GfVec4i &>(self);
+    GfVec4i &vec = boost::python::extract<GfVec4i &>(self);
     *ptrptr = static_cast<void *>(vec.data());
     // Return size in bytes.
     return sizeof(GfVec4i);
diff --git a/pxr/base/tf/envSetting.cpp b/pxr/base/tf/envSetting.cpp
index 41b766903..94e8334a1 100644
--- a/pxr/base/tf/envSetting.cpp
+++ b/pxr/base/tf/envSetting.cpp
@@ -222,7 +222,7 @@ void Tf_InitializeEnvSetting(TfEnvSetting<T> *setting)
 // Explicitly instantiate for the supported types: bool, int, and string.
 template void TF_API Tf_InitializeEnvSetting(TfEnvSetting<bool> *);
 template void TF_API Tf_InitializeEnvSetting(TfEnvSetting<int> *);
-template void TF_API Tf_InitializeEnvSetting(TfEnvSetting<string> *);
+template void TF_API Tf_InitializeEnvSetting(TfEnvSetting<std::string> *);
 
 TF_API
 boost::variant<int, bool, std::string> const *
diff --git a/pxr/base/tf/fileUtils.cpp b/pxr/base/tf/fileUtils.cpp
index fdadb4f56..1c0c9f3e8 100644
--- a/pxr/base/tf/fileUtils.cpp
+++ b/pxr/base/tf/fileUtils.cpp
@@ -66,7 +66,7 @@ PXR_NAMESPACE_OPEN_SCOPE
 // attributes by testing: (actual & attributes) == expected
 bool
 Tf_HasAttribute(
-    string const& path,
+    std::string const& path,
     bool resolveSymlinks,
     DWORD attribute,
     DWORD expected)
@@ -103,7 +103,7 @@ Tf_HasAttribute(
 // Same as above but the bits in attribute must all be set.
 bool
 Tf_HasAttribute(
-    string const& path,
+    std::string const& path,
     bool resolveSymlinks,
     DWORD attribute)
 {
@@ -300,7 +300,7 @@ static bool
 Tf_MakeDirsRec(std::string const& path, int mode, bool existOk)
 {
 #if defined(ARCH_OS_WINDOWS)
-    static const string pathsep = "\\/";
+    static const std::string pathsep = "\\/";
 #else
     static const std::string pathsep = "/";
 #endif
diff --git a/pxr/base/tf/makePyConstructor.h b/pxr/base/tf/makePyConstructor.h
index 255a90ff3..74f17176f 100644
--- a/pxr/base/tf/makePyConstructor.h
+++ b/pxr/base/tf/makePyConstructor.h
@@ -449,13 +449,13 @@ struct InitCtor<SIGNATURE> : CtorBase<SIGNATURE> {
     InitCtor(Sig *func) { Base::SetFunc(func); }
 
     template <typename CLS>
-    static bp::object init_callable() {
-        return bp::make_function(__init__<CLS>);
+    static boost::python::object init_callable() {
+        return boost::python::make_function(__init__<CLS>);
     }
 
     template <typename CLS, typename Options>
-    static bp::object init_callable(Options& o) {
-        return bp::make_function(__init__<CLS>, o.policies(), o.keywords()) ;
+    static boost::python::object init_callable(Options& o) {
+        return boost::python::make_function(__init__<CLS>, o.policies(), o.keywords()) ;
     }
 
     template <typename CLS>
@@ -472,21 +472,21 @@ struct NewCtor<SIGNATURE> : CtorBase<SIGNATURE> {
     NewCtor(Sig *func) { Base::SetFunc(func); }
 
     template <class CLS>
-    static bp::object __new__(object &cls PARAMLIST) {
+    static boost::python::object __new__(object &cls PARAMLIST) {
         typedef typename CLS::metadata::held_type HeldType;
         TfErrorMark m;
         R r((Base::_func(ARGLIST)));
         HeldType h((r));
         if (TfPyConvertTfErrorsToPythonException(m))
-            bp::throw_error_already_set();
-        bp::object ret = TfPyObject(h);
+            boost::python::throw_error_already_set();
+        boost::python::object ret = TfPyObject(h);
         if (TfPyIsNone(ret))
             TfPyThrowRuntimeError("could not construct " +
                                   ArchGetDemangled(typeid(HeldType)));
 
-        bp::detail::initialize_wrapper(ret.ptr(), get_pointer(h));
+        boost::python::detail::initialize_wrapper(ret.ptr(), get_pointer(h));
         // make the object have the right class.
-        bp::setattr(ret, "__class__", cls);
+        boost::python::setattr(ret, "__class__", cls);
 
         InstallPolicy<R>::PostInstall(ret, r, h.GetUniqueIdentifier());
         return ret;
@@ -495,15 +495,15 @@ struct NewCtor<SIGNATURE> : CtorBase<SIGNATURE> {
 
 #define VAR_SIGNATURE                                   \
     R (BOOST_PP_ENUM_PARAMS(N, A) BOOST_PP_COMMA_IF(N)  \
-       const bp::tuple&, const bp::dict&)
+       const boost::python::tuple&, const boost::python::dict&)
 
 #define FORMAT_STR(z, n, data) "%s, "
-#define ARG_TYPE_STR_A(z, n, data) bp::type_id<A##n>().name()
+#define ARG_TYPE_STR_A(z, n, data) boost::python::type_id<A##n>().name()
 
 #define EXTRACT_REQ_ARG_A(z, n, data)                                     \
     /* The n'th required arg is stored at n + 1 in the positional args */ \
     /* tuple as the 0'th element is always the self object */             \
-    bp::extract<typename boost::remove_reference<A##n>::type>(data[n + 1])
+    boost::python::extract<typename boost::remove_reference<A##n>::type>(data[n + 1])
 
 template <typename R BOOST_PP_ENUM_TRAILING_PARAMS(N, typename A)>
 struct InitCtorWithVarArgs<VAR_SIGNATURE> : CtorBase<VAR_SIGNATURE> {
@@ -512,27 +512,27 @@ struct InitCtorWithVarArgs<VAR_SIGNATURE> : CtorBase<VAR_SIGNATURE> {
     InitCtorWithVarArgs(Sig *func) { Base::SetFunc(func); }
 
     template <typename CLS>
-    static bp::object init_callable() {
+    static boost::python::object init_callable() {
         // Specify min_args as 1 to account for just the 'self' argument.
         // min_args really should be N + 1. However, we want to do this check
         // ourselves later so we can emit a better error message.
-        return bp::raw_function(__init__<CLS>, /* min_args = */ 1);
+        return boost::python::raw_function(__init__<CLS>, /* min_args = */ 1);
     }
 
     template <typename CLS, typename Options>
-    static bp::object init_callable(Options& options) {
+    static boost::python::object init_callable(Options& options) {
         // XXX: Note ignoring options.keywords(), current implementation can't
         //      handle that correctly.
-        return bp::raw_function(
-            bp::make_function(__init__<CLS>, options.policies()),
+        return boost::python::raw_function(
+            boost::python::make_function(__init__<CLS>, options.policies()),
             /* min_args = */ 1);
     }
 
     template <typename CLS>
-    static bp::object __init__(const bp::tuple& args, const bp::dict& kwargs) {
+    static boost::python::object __init__(const boost::python::tuple& args, const boost::python::dict& kwargs) {
         TfErrorMark m;
 
-        const unsigned int numArgs = bp::len(args);
+        const unsigned int numArgs = boost::python::len(args);
         if (numArgs - 1 < N) {
             // User didn't provide enough positional arguments for the factory
             // function. Complain.
@@ -543,7 +543,7 @@ struct InitCtorWithVarArgs<VAR_SIGNATURE> : CtorBase<VAR_SIGNATURE> {
                     BOOST_PP_COMMA_IF(N) BOOST_PP_ENUM(N, ARG_TYPE_STR_A, 0)
                 )
             );
-            return bp::object();
+            return boost::python::object();
         }
 
         Install<CLS>(
@@ -554,10 +554,10 @@ struct InitCtorWithVarArgs<VAR_SIGNATURE> : CtorBase<VAR_SIGNATURE> {
             // those are the required arguments for the factory function.
             Base::_func(
                 BOOST_PP_ENUM(N, EXTRACT_REQ_ARG_A, args) BOOST_PP_COMMA_IF(N)
-                bp::tuple(args.slice(N + 1, numArgs)), kwargs),
+                boost::python::tuple(args.slice(N + 1, numArgs)), kwargs),
             m);
 
-        return bp::object();
+        return boost::python::object();
     }
 
 };
@@ -579,13 +579,13 @@ struct InitCtorWithBackReference<SIGNATURE> : CtorBase<SIGNATURE> {
     InitCtorWithBackReference(Sig *func) { Base::SetFunc(func); }
 
     template <typename CLS>
-    static bp::object init_callable() {
-        return bp::make_function(__init__<CLS>);
+    static boost::python::object init_callable() {
+        return boost::python::make_function(__init__<CLS>);
     }
 
     template <typename CLS, typename Options>
-    static bp::object init_callable(Options& o) {
-        return bp::make_function(__init__<CLS>, o.policies(), o.keywords());
+    static boost::python::object init_callable(Options& o) {
+        return boost::python::make_function(__init__<CLS>, o.policies(), o.keywords());
     }
 
     template <typename CLS>
@@ -602,21 +602,21 @@ struct NewCtorWithClassReference<SIGNATURE> : CtorBase<SIGNATURE> {
     NewCtorWithClassReference(Sig *func) { Base::SetFunc(func); }
 
     template <class CLS>
-    static bp::object __new__(PARAMLIST) {
+    static boost::python::object __new__(PARAMLIST) {
         typedef typename CLS::metadata::held_type HeldType;
         TfErrorMark m;
         R r(Base::_func(ARGLIST));
         HeldType h(r);
         if (TfPyConvertTfErrorsToPythonException(m))
-            bp::throw_error_already_set();
-        bp::object ret = TfPyObject(h);
+            boost::python::throw_error_already_set();
+        boost::python::object ret = TfPyObject(h);
         if (TfPyIsNone(ret))
             TfPyThrowRuntimeError("could not construct " +
                                   ArchGetDemangled(typeid(HeldType)));
 
-        bp::detail::initialize_wrapper(ret.ptr(), get_pointer(h));
+        boost::python::detail::initialize_wrapper(ret.ptr(), get_pointer(h));
         // make the object have the right class.
-        bp::setattr(ret, "__class__", a0);
+        boost::python::setattr(ret, "__class__", a0);
 
         InstallPolicy<R>::PostInstall(ret, r, h.GetUniqueIdentifier());
         return ret;
diff --git a/pxr/base/tf/pathUtils.cpp b/pxr/base/tf/pathUtils.cpp
index 975a3724b..052f00f7b 100644
--- a/pxr/base/tf/pathUtils.cpp
+++ b/pxr/base/tf/pathUtils.cpp
@@ -145,7 +145,7 @@ TfRealPath(std::string const& path, bool allowInaccessibleSuffix, std::string* e
     // Expand all symbolic links.
     if (!TfPathExists(prefix)) {
         *error = "the named file does not exist";
-        return string();
+        return std::string();
     }
     std::string resolved = _ExpandSymlinks(prefix);
 
@@ -323,19 +323,19 @@ namespace {
 static
 void
 Tf_Glob(
-    vector<string>* result,
+    std::vector<std::string>* result,
     const std::string& prefix,
     const std::string& pattern,
     unsigned int flags)
 {
     // Search for the first wildcard in pattern.
-    const string::size_type i = pattern.find_first_of("*?");
+    const std::string::size_type i = pattern.find_first_of("*?");
 
-    if (i == string::npos) {
+    if (i == std::string::npos) {
         // No more patterns so we simply need to see if the file exists.
         // Conveniently GetFileAttributes() works on paths with a trailing
         // backslash.
-        string path = prefix + pattern;
+        std::string path = prefix + pattern;
             const DWORD attributes =
                 GetFileAttributesW(ArchWindowsUtf8ToUtf16(path).c_str());
         if (attributes != INVALID_FILE_ATTRIBUTES) {
@@ -354,20 +354,20 @@ Tf_Glob(
     else {
         // There are additional patterns to glob.  Find the next directory
         // after the wildcard.
-        string::size_type j = pattern.find_first_of('\\', i);
-        if (j == string::npos) {
+        std::string::size_type j = pattern.find_first_of('\\', i);
+        if (j == std::string::npos) {
             // We've bottomed out on the pattern.
             j = pattern.size();
         }
 
         // Construct the remaining pattern, if any.
-        const string remainingPattern = pattern.substr(j);
+        const std::string remainingPattern = pattern.substr(j);
 
         // Construct the leftmost pattern.
-        const string leftmostPattern = prefix + pattern.substr(0, j);
+        const std::string leftmostPattern = prefix + pattern.substr(0, j);
 
         // Construct the leftmost pattern's directory. 
-        const string leftmostDir = TfGetPathName(leftmostPattern);
+        const std::string leftmostDir = TfGetPathName(leftmostPattern);
 
         // Glob the leftmost pattern.
         WIN32_FIND_DATAW data;
@@ -387,10 +387,10 @@ Tf_Glob(
 
 }
 
-vector<string>
-TfGlob(vector<string> const& paths, unsigned int flags)
+std::vector<std::string>
+TfGlob(std::vector<std::string> const& paths, unsigned int flags)
 {
-    vector<string> result;
+    std::vector<std::string> result;
 
     for (auto path: paths) {
         const size_t n = result.size();
diff --git a/pxr/base/tf/pyFunction.h b/pxr/base/tf/pyFunction.h
index afa58b806..11e5e95a5 100644
--- a/pxr/base/tf/pyFunction.h
+++ b/pxr/base/tf/pyFunction.h
@@ -94,7 +94,7 @@ struct TfPyFunctionFromPython<Ret (Args...)>
                 return Ret();
             }
 #if PY_MAJOR_VERSION == 2
-            object method(handle<>(PyMethod_New(func.ptr(), self, cls.ptr())));
+            boost::python::object method(boost::python::handle<>(PyMethod_New(func.ptr(), self, cls.ptr())));
 #else 
             boost::python::object method(boost::python::handle<>(PyMethod_New(func.ptr(), self)));
 #endif
@@ -158,7 +158,7 @@ struct TfPyFunctionFromPython<Ret (Args...)>
                 // Deconstruct the method and attempt to get a weak reference to
                 // the self instance.
 #if PY_MAJOR_VERSION == 2
-                object cls(handle<>(borrowed(PyMethod_GET_CLASS(pyCallable))));
+                boost::python::object cls(boost::python::handle<>(boost::python::borrowed(PyMethod_GET_CLASS(pyCallable))));
 #endif
                 boost::python::object func(boost::python::handle<>(boost::python::borrowed(PyMethod_GET_FUNCTION(
                                                   pyCallable))));
diff --git a/pxr/base/tf/pyIdentity.cpp b/pxr/base/tf/pyIdentity.cpp
index 9247bfc8b..70c0ea1fa 100644
--- a/pxr/base/tf/pyIdentity.cpp
+++ b/pxr/base/tf/pyIdentity.cpp
@@ -195,7 +195,7 @@ static std::string _GetTypeName(PyObject *obj) {
 using std::map;
 using std::make_pair;
 
-TfStaticData<map<void const *, string> > _establishedIdentityStacks;
+TfStaticData<map<void const *, std::string> > _establishedIdentityStacks;
 
 static void _RecordEstablishedIdentityStack(void const *key)
 {
diff --git a/pxr/base/tf/pyModule.cpp b/pxr/base/tf/pyModule.cpp
index 384349887..2277c5295 100644
--- a/pxr/base/tf/pyModule.cpp
+++ b/pxr/base/tf/pyModule.cpp
@@ -123,7 +123,7 @@ private:
             boost::python::object items_view = obj.attr("__dict__").attr("items")();
             boost::python::list items(items_view);
 #else
-            list items = extract<list>(obj.attr("__dict__").attr("items")());
+            boost::python::list items = boost::python::extract<boost::python::list>(obj.attr("__dict__").attr("items")());
 #endif
             size_t lenItems = boost::python::len(items);
             for (size_t i = 0; i < lenItems; ++i) {
diff --git a/pxr/base/tf/pyObjWrapper.cpp b/pxr/base/tf/pyObjWrapper.cpp
index a9c842b58..7c9478bc3 100644
--- a/pxr/base/tf/pyObjWrapper.cpp
+++ b/pxr/base/tf/pyObjWrapper.cpp
@@ -65,7 +65,7 @@ TfPyObjWrapper::TfPyObjWrapper()
 }
 
 TfPyObjWrapper::TfPyObjWrapper(boost::python::object obj)
-    : _objectPtr(new object(obj), _DeleteObjectWithLock())
+    : _objectPtr(new boost::python::object(obj), _DeleteObjectWithLock())
 {
 }
 
diff --git a/pxr/base/tf/stringUtils.cpp b/pxr/base/tf/stringUtils.cpp
index dbd0545eb..9a3d91ced 100644
--- a/pxr/base/tf/stringUtils.cpp
+++ b/pxr/base/tf/stringUtils.cpp
@@ -320,7 +320,7 @@ TfGetBaseName(const std::string& fileName)
     if (fileName.empty())
         return fileName;
 #if defined(ARCH_OS_WINDOWS)
-    const string::size_type i = fileName.find_last_of("\\/");
+    const std::string::size_type i = fileName.find_last_of("\\/");
 #else
     const std::string::size_type i = fileName.rfind("/");
 #endif
@@ -336,8 +336,8 @@ TfGetBaseName(const std::string& fileName)
     // fileName was already basename, in which case we want to return the
     // string back.
     if (result == wfileName.c_str()) {
-        const bool hasDriveLetter = fileName.find(":") != string::npos;
-        const bool hasPathSeparator  = i != string::npos;
+        const bool hasDriveLetter = fileName.find(":") != std::string::npos;
+        const bool hasPathSeparator  = i != std::string::npos;
         if (hasDriveLetter || hasPathSeparator) {
             return std::string();
         }
diff --git a/pxr/base/vt/arrayPyBuffer.cpp b/pxr/base/vt/arrayPyBuffer.cpp
index 3e49e6258..24c10acfe 100644
--- a/pxr/base/vt/arrayPyBuffer.cpp
+++ b/pxr/base/vt/arrayPyBuffer.cpp
@@ -221,7 +221,7 @@ Vt_getreadbuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
         PyErr_SetString(PyExc_ValueError, "accessed non-existent segment");
         return -1;
     }
-    T &selfT = bp::extract<T &>(self);
+    T &selfT = boost::python::extract<T &>(self);
     *ptrptr = const_cast<void *>(static_cast<void const *>(selfT.cdata()));
     // Return size in bytes.
     return selfT.size() * sizeof(typename T::value_type);
@@ -239,7 +239,7 @@ Vt_getwritebuf(PyObject *self, Py_ssize_t segment, void **ptrptr) {
 template <class T>
 Py_ssize_t
 Vt_getsegcount(PyObject *self, Py_ssize_t *lenp) {
-    T &selfT = bp::extract<T &>(self);
+    T &selfT = boost::python::extract<T &>(self);
     if (lenp)
         *lenp = selfT.size() * sizeof(typename T::value_type);
     return 1; // Always one contiguous segment.
@@ -593,7 +593,7 @@ VtArrayFromPyBuffer(TfPyObjWrapper const &obj, std::string *err)
 
 #define INSTANTIATE(r, unused, elem)                                       \
 template boost::optional<VtArray<VT_TYPE(elem)> >                          \
-VtArrayFromPyBuffer<VT_TYPE(elem)>(TfPyObjWrapper const &obj, string *err);
+VtArrayFromPyBuffer<VT_TYPE(elem)>(TfPyObjWrapper const &obj, std::string *err);
 BOOST_PP_SEQ_FOR_EACH(INSTANTIATE, ~, VT_ARRAY_PYBUFFER_TYPES)
 #undef INSTANTIATE
 
diff --git a/pxr/base/vt/pyOperators.h b/pxr/base/vt/pyOperators.h
index e1eadd182..86bb72c77 100644
--- a/pxr/base/vt/pyOperators.h
+++ b/pxr/base/vt/pyOperators.h
@@ -37,33 +37,33 @@ PXR_NAMESPACE_OPEN_SCOPE
 
 // base macro called by wrapping layers below for various operators, python
 // types (lists and tuples), and special methods
-#define VTOPERATOR_WRAP_PYTYPE_BASE(op,method,pytype,rettype,expr)           \
-    template <typename T> static                                             \
-    VtArray<rettype> method##pytype(VtArray<T> vec, pytype obj)              \
-    {                                                                        \
-        size_t length = len(obj);                                            \
-        if (length != vec.size()) {                                          \
-            TfPyThrowValueError("Non-conforming inputs for operator " #op);  \
-            return VtArray<T>();                                             \
-        }                                                                    \
-        VtArray<rettype> ret(vec.size());                                    \
-        for (size_t i = 0; i < length; ++i) {                                \
-            if (!extract<T>(obj[i]).check())                                 \
-                TfPyThrowValueError("Element is of incorrect type.");        \
-            ret[i] = expr;                                                   \
-        }                                                                    \
-        return ret;                                                          \
-    }
+#define VTOPERATOR_WRAP_PYTYPE_BASE(op,method,pytype,rettype,expr)             \
+    template <typename T> static                                               \
+    VtArray<rettype> method##pytype(VtArray<T> vec, boost::python::pytype obj) \
+    {                                                                          \
+        size_t length = boost::python::len(obj);                               \
+        if (length != vec.size()) {                                            \
+            TfPyThrowValueError("Non-conforming inputs for operator " #op);    \
+            return VtArray<T>();                                               \
+        }                                                                      \
+        VtArray<rettype> ret(vec.size());                                      \
+        for (size_t i = 0; i < length; ++i) {                                  \
+            if (!boost::python::extract<T>(obj[i]).check())                    \
+                TfPyThrowValueError("Element is of incorrect type.");          \
+            ret[i] = expr;                                                     \
+        }                                                                      \
+        return ret;                                                            \
+     }
 
 // wrap Array op pytype
 #define VTOPERATOR_WRAP_PYTYPE(op,lmethod,tuple,T)                             \
     VTOPERATOR_WRAP_PYTYPE_BASE(op,lmethod,tuple,T,                            \
-                                (vec[i] op (T)extract<T>(obj[i])) )
+                                (vec[i] op (T)boost::python::extract<T>(obj[i])) )
 
 // wrap pytype op Array (for noncommutative ops like subtraction)
 #define VTOPERATOR_WRAP_PYTYPE_R(op,lmethod,tuple,T)                           \
     VTOPERATOR_WRAP_PYTYPE_BASE(op,lmethod,tuple,T,                            \
-                                ((T)extract<T>(obj[i]) op vec[i]) )
+                                ((T)boost::python::extract<T>(obj[i]) op vec[i]) )
 
 
 // operator that needs a special method plus a reflected special method,
@@ -83,9 +83,9 @@ PXR_NAMESPACE_OPEN_SCOPE
 
 // to be used to actually declare the wrapping with def() on the class
 #define VTOPERATOR_WRAPDECLARE_BASE(op,method,rettype)      \
-    .def(self op self)                                      \
-    .def(self op Type())                                    \
-    .def(Type() op self)                                    \
+    .def(boost::python::self op boost::python::self)        \
+    .def(boost::python::self op Type())                     \
+    .def(Type() op boost::python::self)                     \
     .def(#method,method##tuple<rettype>)                    \
     .def(#method,method##list<rettype>)                      
 
@@ -100,14 +100,14 @@ PXR_NAMESPACE_OPEN_SCOPE
     template <typename T> static                                      \
     VtArray<bool> Vt##func(arg1, arg2)                                \
     {                                                                 \
-        size_t length = len(obj);                                     \
+        size_t length = boost::python::len(obj);                      \
         if (length != vec.size()) {                                   \
             TfPyThrowValueError("Non-conforming inputs for " #func);  \
             return VtArray<bool>();                                   \
         }                                                             \
         VtArray<bool> ret(vec.size());                                \
         for (size_t i = 0; i < length; ++i) {                         \
-            if (!extract<T>(obj[i]).check())                          \
+            if (!boost::python::extract<T>(obj[i]).check())           \
                 TfPyThrowValueError("Element is of incorrect type."); \
             ret[i] = expr;                                            \
         }                                                             \
@@ -116,40 +116,40 @@ PXR_NAMESPACE_OPEN_SCOPE
 
 // array OP pytype
 // pytype OP array
-#define VTOPERATOR_WRAP_PYTYPE_BOOL(func,pytype,op)         \
-        VTOPERATOR_WRAP_PYTYPE_BOOL_BASE(func,              \
-            VtArray<T> const &vec, pytype const &obj,       \
-            (vec[i] op (T)extract<T>(obj[i])) )             \
-        VTOPERATOR_WRAP_PYTYPE_BOOL_BASE(func,              \
-            pytype const &obj,VtArray<T> const &vec,        \
-            ((T)extract<T>(obj[i]) op vec[i]) )             
+#define VTOPERATOR_WRAP_PYTYPE_BOOL(func,pytype,op)                  \
+        VTOPERATOR_WRAP_PYTYPE_BOOL_BASE(func,                       \
+            VtArray<T> const &vec, boost::python::pytype const &obj, \
+            (vec[i] op (T)boost::python::extract<T>(obj[i])) )       \
+        VTOPERATOR_WRAP_PYTYPE_BOOL_BASE(func,                       \
+            boost::python::pytype const &obj,VtArray<T> const &vec,  \
+            ((T)boost::python::extract<T>(obj[i]) op vec[i]) )
 
 #define VTOPERATOR_WRAP_BOOL(func,op)                       \
         VTOPERATOR_WRAP_PYTYPE_BOOL(func,list,op)           \
         VTOPERATOR_WRAP_PYTYPE_BOOL(func,tuple,op)          
 
 // to be used to actually declare the wrapping with def() on the class
-#define VTOPERATOR_WRAPDECLARE_BOOL(func)                   \
-       def(#func,(VtArray<bool> (*)                         \
-            (VtArray<Type> const &,VtArray<Type> const &))  \
-            Vt##func<Type>);                                \
-        def(#func,(VtArray<bool> (*)                        \
-            (Type const &,VtArray<Type> const &))           \
-            Vt##func<Type>);                                \
-        def(#func,(VtArray<bool> (*)                        \
-            (VtArray<Type> const &,Type const &))           \
-            Vt##func<Type>);                                \
-        def(#func,(VtArray<bool> (*)                        \
-            (VtArray<Type> const &,tuple const &))          \
-            Vt##func<Type>);                                \
-        def(#func,(VtArray<bool> (*)                        \
-            (tuple const &,VtArray<Type> const &))          \
-            Vt##func<Type>);                                \
-        def(#func,(VtArray<bool> (*)                        \
-            (VtArray<Type> const &,list const &))           \
-            Vt##func<Type>);                                \
-        def(#func,(VtArray<bool> (*)                        \
-            (list const &,VtArray<Type> const &))           \
+#define VTOPERATOR_WRAPDECLARE_BOOL(func)                         \
+       boost::python::def(#func,(VtArray<bool> (*)                \
+            (VtArray<Type> const &,VtArray<Type> const &))        \
+            Vt##func<Type>);                                      \
+        boost::python::def(#func,(VtArray<bool> (*)               \
+            (Type const &,VtArray<Type> const &))                 \
+            Vt##func<Type>);                                      \
+        boost::python::def(#func,(VtArray<bool> (*)               \
+            (VtArray<Type> const &,Type const &))                 \
+            Vt##func<Type>);                                      \
+        boost::python::def(#func,(VtArray<bool> (*)               \
+            (VtArray<Type> const &,boost::python::tuple const &)) \
+            Vt##func<Type>);                                      \
+        boost::python::def(#func,(VtArray<bool> (*)               \
+            (boost::python::tuple const &,VtArray<Type> const &)) \
+            Vt##func<Type>);                                      \
+        boost::python::def(#func,(VtArray<bool> (*)               \
+            (VtArray<Type> const &,boost::python::list const &))  \
+            Vt##func<Type>);                                      \
+        boost::python::def(#func,(VtArray<bool> (*)               \
+            (boost::python::list const &,VtArray<Type> const &))  \
             Vt##func<Type>);                                
 
 PXR_NAMESPACE_CLOSE_SCOPE
diff --git a/pxr/base/vt/wrapArray.h b/pxr/base/vt/wrapArray.h
index 0c33926c9..a51c9bdd9 100644
--- a/pxr/base/vt/wrapArray.h
+++ b/pxr/base/vt/wrapArray.h
@@ -509,14 +509,14 @@ void VtWrapArray()
         VTOPERATOR_WRAPDECLARE(%,__mod__,__rmod__)
 #endif
 #ifdef DOUBLE_MULT_OPERATOR
-        .def(self * double())
-        .def(double() * self)
+        .def(boost::python::self * double())
+        .def(double() * boost::python::self)
 #endif
 #ifdef DOUBLE_DIV_OPERATOR
-        .def(self / double())
+        .def(boost::python::self / double())
 #endif
 #ifdef UNARY_NEG_OPERATOR
-        .def(- self)
+        .def(- boost::python::self)
 #endif
 
         ;
diff --git a/pxr/imaging/cameraUtil/wrapConformWindow.cpp b/pxr/imaging/cameraUtil/wrapConformWindow.cpp
index d620b9b33..155dc81c3 100644
--- a/pxr/imaging/cameraUtil/wrapConformWindow.cpp
+++ b/pxr/imaging/cameraUtil/wrapConformWindow.cpp
@@ -36,6 +36,7 @@
 
 #include <boost/python.hpp>
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -60,20 +61,20 @@ wrapConformWindow()
     typedef void (*Signature6)(
         GfFrustum *, CameraUtilConformWindowPolicy, double);
 
-    boost::python::def("ConformedWindow", (Signature1)&CameraUtilConformedWindow,
-        (boost::python::arg("window"), boost::python::arg("policy"), boost::python::arg("targetAspect")));
-    boost::python::def("ConformedWindow", (Signature2)&CameraUtilConformedWindow,
-        (boost::python::arg("window"), boost::python::arg("policy"), boost::python::arg("targetAspect")));
-    boost::python::def("ConformedWindow", (Signature3)&CameraUtilConformedWindow,
-        (boost::python::arg("window"), boost::python::arg("policy"), boost::python::arg("targetAspect")));
-    boost::python::def("ConformedWindow", (Signature4)&CameraUtilConformedWindow,
-        (boost::python::arg("window"), boost::python::arg("policy"), boost::python::arg("targetAspect")));
+    def("ConformedWindow", (Signature1)&CameraUtilConformedWindow,
+        (arg("window"), arg("policy"), arg("targetAspect")));
+    def("ConformedWindow", (Signature2)&CameraUtilConformedWindow,
+        (arg("window"), arg("policy"), arg("targetAspect")));
+    def("ConformedWindow", (Signature3)&CameraUtilConformedWindow,
+        (arg("window"), arg("policy"), arg("targetAspect")));
+    def("ConformedWindow", (Signature4)&CameraUtilConformedWindow,
+        (arg("window"), arg("policy"), arg("targetAspect")));
     
-    boost::python::def("ConformWindow", (Signature5)&CameraUtilConformWindow,
-        (boost::python::arg("camera"), boost::python::arg("policy"), boost::python::arg("targetAspect")));
+    def("ConformWindow", (Signature5)&CameraUtilConformWindow,
+        (arg("camera"), arg("policy"), arg("targetAspect")));
 
-    boost::python::def("ConformWindow", (Signature6)&CameraUtilConformWindow,
-        (boost::python::arg("frustum"), boost::python::arg("policy"), boost::python::arg("targetAspect")));
+    def("ConformWindow", (Signature6)&CameraUtilConformWindow,
+        (arg("frustum"), arg("policy"), arg("targetAspect")));
 
     TfPyWrapEnum<CameraUtilConformWindowPolicy>();
 }
diff --git a/pxr/imaging/cameraUtil/wrapFraming.cpp b/pxr/imaging/cameraUtil/wrapFraming.cpp
index 42475c19a..124687636 100644
--- a/pxr/imaging/cameraUtil/wrapFraming.cpp
+++ b/pxr/imaging/cameraUtil/wrapFraming.cpp
@@ -30,6 +30,7 @@
 
 #include <boost/python.hpp>
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -60,27 +61,27 @@ wrapFraming()
 {
     using This = CameraUtilFraming;
 
-    boost::python::class_<This>("Framing")
-        .def(boost::python::init<>())
-        .def(boost::python::init<const This &>())
-        .def(boost::python::init<const GfRange2f&,
+    class_<This>("Framing")
+        .def(init<>())
+        .def(init<const This &>())
+        .def(init<const GfRange2f&,
                   const GfRect2i&,
                   float>(
-                      (boost::python::args("displayWindow"),
-                       boost::python::args("dataWindow"),
-                       boost::python::args("pixelAspectRatio") = 1.0)))
-        .def(boost::python::init<const GfRect2i>(
-                      ((boost::python::args("dataWindow")))))
+                      (args("displayWindow"),
+                       args("dataWindow"),
+                       args("pixelAspectRatio") = 1.0)))
+        .def(init<const GfRect2i>(
+                      ((args("dataWindow")))))
         .def("ApplyToProjectionMatrix",
              &This::ApplyToProjectionMatrix,
-             ((boost::python::args("projectionMatrix"), boost::python::args("windowPolicy"))))
+             ((args("projectionMatrix"), args("windowPolicy"))))
         .def("IsValid", &This::IsValid)
         .def_readwrite("displayWindow", &This::displayWindow)
         .def_readwrite("dataWindow", &This::dataWindow)
         .def_readwrite("pixelAspectRatio", &This::pixelAspectRatio)
 
-        .def(boost::python::self == boost::python::self)
-        .def(boost::python::self != boost::python::self)
+        .def(self == self)
+        .def(self != self)
 
         .def("__repr__", _Repr)
     ;
diff --git a/pxr/imaging/cameraUtil/wrapScreenWindowParameters.cpp b/pxr/imaging/cameraUtil/wrapScreenWindowParameters.cpp
index b6fc24adc..d4b257e0f 100644
--- a/pxr/imaging/cameraUtil/wrapScreenWindowParameters.cpp
+++ b/pxr/imaging/cameraUtil/wrapScreenWindowParameters.cpp
@@ -29,22 +29,23 @@
 
 #include <boost/python.hpp>
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
 void
 wrapScreenWindowParameters()
 {
-    boost::python::object getScreenWindowFunc =
-        boost::python::make_function(&CameraUtilScreenWindowParameters::GetScreenWindow,
-                      boost::python::return_value_policy<boost::python::copy_const_reference>());
+    object getScreenWindowFunc =
+        make_function(&CameraUtilScreenWindowParameters::GetScreenWindow,
+                      return_value_policy<copy_const_reference>());
 
-    boost::python::object getZFacingViewMatrixFunc =
-        boost::python::make_function(&CameraUtilScreenWindowParameters::GetZFacingViewMatrix,
-                      boost::python::return_value_policy<boost::python::copy_const_reference>());
+    object getZFacingViewMatrixFunc =
+        make_function(&CameraUtilScreenWindowParameters::GetZFacingViewMatrix,
+                      return_value_policy<copy_const_reference>());
 
-    boost::python::class_<CameraUtilScreenWindowParameters>("ScreenWindowParameters", boost::python::no_init)
-        .def(boost::python::init<const GfCamera&>())
+    class_<CameraUtilScreenWindowParameters>("ScreenWindowParameters", no_init)
+        .def(init<const GfCamera&>())
         .add_property("screenWindow", getScreenWindowFunc)
         .add_property("fieldOfView",
                       &CameraUtilScreenWindowParameters::GetFieldOfView)
diff --git a/pxr/imaging/garch/wrapPlatformDebugContext.cpp b/pxr/imaging/garch/wrapPlatformDebugContext.cpp
index 259582193..fd8166ce6 100644
--- a/pxr/imaging/garch/wrapPlatformDebugContext.cpp
+++ b/pxr/imaging/garch/wrapPlatformDebugContext.cpp
@@ -28,6 +28,7 @@
 
 #include <boost/python/class.hpp>
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -35,8 +36,8 @@ void wrapPlatformDebugContext()
 {    
     typedef GarchGLPlatformDebugContext This;
 
-    boost::python::class_<This, TfWeakPtr<This>,
-           boost::noncopyable>("GLPlatformDebugContext", boost::python::no_init)
+    class_<This, TfWeakPtr<This>,
+           boost::noncopyable>("GLPlatformDebugContext", no_init)
         .def(TfPyRefAndWeakPtr())
         .def(TfMakePyConstructor(GarchGLPlatformDebugContext::New))
         .def("makeCurrent", &This::makeCurrent)
diff --git a/pxr/imaging/glf/info.cpp b/pxr/imaging/glf/info.cpp
index 179156969..3394d2c70 100644
--- a/pxr/imaging/glf/info.cpp
+++ b/pxr/imaging/glf/info.cpp
@@ -38,17 +38,20 @@
 PXR_NAMESPACE_OPEN_SCOPE
 
 
+using std::set;
+using std::string;
+using std::vector;
 
-static std::set<std::string>
+static set<string>
 Glf_BuildAvailableExtensions()
 {
     GlfSharedGLContextScopeHolder sharedContextScopeHolder;
 
-    std::set<std::string> availableExtensions;
+    set<string> availableExtensions;
 
     // Get the available extensions from OpenGL if we haven't yet.
     if (const char *extensions = (const char*) glGetString(GL_EXTENSIONS)) {
-        const std::vector<std::string> extensionsList = TfStringTokenize(extensions);
+        const vector<string> extensionsList = TfStringTokenize(extensions);
         for (std::string const& extension : extensionsList) {
             availableExtensions.insert(extension);
         }
@@ -57,12 +60,12 @@ Glf_BuildAvailableExtensions()
 }
 
 bool
-GlfHasExtensions(std::string const & queryExtensions)
+GlfHasExtensions(string const & queryExtensions)
 {
-    static std::set<std::string> availableExtensions = Glf_BuildAvailableExtensions();
+    static set<string> availableExtensions = Glf_BuildAvailableExtensions();
 
     // Tokenize the queried extensions.
-    const std::vector<std::string> extensionsList = TfStringTokenize(queryExtensions);
+    const vector<string> extensionsList = TfStringTokenize(queryExtensions);
 
     // Return false if any queried extension is not available.
     for (std::string const& extension : extensionsList) {
diff --git a/pxr/imaging/glf/wrapDiagnostic.cpp b/pxr/imaging/glf/wrapDiagnostic.cpp
index fae56f5a6..b0dfb363d 100644
--- a/pxr/imaging/glf/wrapDiagnostic.cpp
+++ b/pxr/imaging/glf/wrapDiagnostic.cpp
@@ -26,15 +26,16 @@
 #include <boost/python/def.hpp>
 #include <boost/python/class.hpp>
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
 void wrapDiagnostic()
 {    
-    boost::python::def("RegisterDefaultDebugOutputMessageCallback",
+    def("RegisterDefaultDebugOutputMessageCallback",
         &GlfRegisterDefaultDebugOutputMessageCallback);
 
-    boost::python::class_<GlfGLQueryObject, boost::noncopyable>("GLQueryObject")
+    class_<GlfGLQueryObject, boost::noncopyable>("GLQueryObject")
         .def("Begin", &GlfGLQueryObject::Begin)
         .def("BeginPrimitivesGenerated", &GlfGLQueryObject::BeginPrimitivesGenerated)
         .def("BeginTimeElapsed", &GlfGLQueryObject::BeginTimeElapsed)
diff --git a/pxr/imaging/glf/wrapDrawTarget.cpp b/pxr/imaging/glf/wrapDrawTarget.cpp
index 437d168fd..a0001cd1f 100644
--- a/pxr/imaging/glf/wrapDrawTarget.cpp
+++ b/pxr/imaging/glf/wrapDrawTarget.cpp
@@ -32,6 +32,7 @@
 #include <boost/python/class.hpp>
 #include <boost/python/overloads.hpp>
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -56,7 +57,7 @@ void wrapDrawTarget()
     typedef GlfDrawTarget This;
     typedef GlfDrawTargetPtr ThisPtr;
     
-    boost::python::class_<This, ThisPtr, boost::noncopyable>("DrawTarget", boost::python::no_init)
+    class_<This, ThisPtr, boost::noncopyable>("DrawTarget", no_init)
         .def(TfPyRefAndWeakPtr())
         .def("__init__",TfMakePyConstructor(&_NewDrawTarget))
         .def("__init__",TfMakePyConstructor(&_NewDrawTarget2))
@@ -65,10 +66,10 @@ void wrapDrawTarget()
         .def("Unbind", &This::Unbind)
         .def("WriteToFile", 
             &This::WriteToFile, (
-             boost::python::arg("attachment"),
-             boost::python::arg("filename"),
-             boost::python::arg("viewMatrix") = GfMatrix4d(1),
-             boost::python::arg("projectionMatrix") = GfMatrix4d(1)))
+             arg("attachment"),
+             arg("filename"),
+             arg("viewMatrix") = GfMatrix4d(1),
+             arg("projectionMatrix") = GfMatrix4d(1)))
         
         ;
 }
diff --git a/pxr/imaging/glf/wrapSimpleLight.cpp b/pxr/imaging/glf/wrapSimpleLight.cpp
index 15b2a83d6..376f5db48 100644
--- a/pxr/imaging/glf/wrapSimpleLight.cpp
+++ b/pxr/imaging/glf/wrapSimpleLight.cpp
@@ -25,6 +25,7 @@
 
 #include <boost/python/class.hpp>
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -32,101 +33,101 @@ void wrapSimpleLight()
 {
     typedef GlfSimpleLight This;
 
-    boost::python::class_<This> ("SimpleLight", boost::python::init<>() )
+    class_<This> ("SimpleLight", init<>() )
         .add_property("transform",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetTransform,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetTransform)
         .add_property("ambient",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetAmbient,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetAmbient)
         .add_property("diffuse",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetDiffuse,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetDiffuse)
         .add_property("specular",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetSpecular,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetSpecular)
         .add_property("position",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetPosition,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetPosition)
         .add_property("spotDirection",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetSpotDirection,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetSpotDirection)
         .add_property("spotCutoff",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetSpotCutoff,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetSpotCutoff)
         .add_property("spotFalloff",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetSpotFalloff,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetSpotFalloff)
         .add_property("attenuation",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetAttenuation,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetAttenuation)
         .add_property("shadowMatrices",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetShadowMatrices,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetShadowMatrices)
         .add_property("shadowResolution",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetShadowResolution,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetShadowResolution)
         .add_property("shadowBias",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetShadowBias,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetShadowBias)
         .add_property("shadowBlur",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetShadowBlur,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetShadowBlur)
         .add_property("shadowIndexStart",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetShadowIndexStart,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetShadowIndexStart)
         .add_property("shadowIndexEnd",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetShadowIndexEnd,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetShadowIndexEnd)
         .add_property("hasShadow",
-                      boost::python::make_function(
+                      make_function(
                           &This::HasShadow,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetHasShadow)
         .add_property("isCameraSpaceLight",
-                      boost::python::make_function(
+                      make_function(
                           &This::IsCameraSpaceLight,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetIsCameraSpaceLight)
         .add_property("id",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetID,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetID)
         .add_property("isDomeLight",
-                      boost::python::make_function(
+                      make_function(
                           &This::IsDomeLight,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetIsDomeLight)
         ;
 }
diff --git a/pxr/imaging/glf/wrapSimpleMaterial.cpp b/pxr/imaging/glf/wrapSimpleMaterial.cpp
index 905e96f1c..3d5b9b4d5 100644
--- a/pxr/imaging/glf/wrapSimpleMaterial.cpp
+++ b/pxr/imaging/glf/wrapSimpleMaterial.cpp
@@ -25,6 +25,7 @@
 
 #include <boost/python/class.hpp>
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -32,31 +33,31 @@ void wrapSimpleMaterial()
 {
     typedef GlfSimpleMaterial This;
 
-    boost::python::class_<This> ("SimpleMaterial", boost::python::init<>())
+    class_<This> ("SimpleMaterial", init<>())
         .add_property("ambient",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetAmbient,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetAmbient)
         .add_property("diffuse",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetDiffuse,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetDiffuse)
         .add_property("specular",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetSpecular,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetSpecular)
         .add_property("emission",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetEmission,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetEmission)
         .add_property("shininess",
-                      boost::python::make_function(
+                      make_function(
                           &This::GetShininess,
-                          boost::python::return_value_policy<boost::python::return_by_value>()),
+                          return_value_policy<return_by_value>()),
                       &This::SetShininess)
         ;
 }
diff --git a/pxr/imaging/glf/wrapTexture.cpp b/pxr/imaging/glf/wrapTexture.cpp
index b80b67dee..fb449a5d8 100644
--- a/pxr/imaging/glf/wrapTexture.cpp
+++ b/pxr/imaging/glf/wrapTexture.cpp
@@ -30,6 +30,7 @@
 #include <boost/python/class.hpp>
 #include <boost/python/overloads.hpp>
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -38,27 +39,27 @@ void wrapTexture()
     typedef GlfTexture This;
     typedef GlfTexturePtr ThisPtr;
 
-    boost::python::class_<This, ThisPtr, boost::noncopyable>(
-        "Texture", boost::python::no_init)
+    class_<This, ThisPtr, boost::noncopyable>(
+        "Texture", no_init)
         .def("GetTextureMemoryAllocated", &This::GetTextureMemoryAllocated)
         .staticmethod("GetTextureMemoryAllocated")
 
-        .add_property( "memoryUsed", boost::python::make_function(
+        .add_property( "memoryUsed", make_function(
                 &This::GetMemoryUsed,
-                boost::python::return_value_policy<boost::python::return_by_value>()))
+                return_value_policy<return_by_value>()))
 
-        .add_property( "memoryRequested", boost::python::make_function(
+        .add_property( "memoryRequested", make_function(
                 &This::GetMemoryRequested,
-                boost::python::return_value_policy<boost::python::return_by_value>()),
+                return_value_policy<return_by_value>()),
                 &This::SetMemoryRequested)
 
-        .add_property( "minFilterSupported", boost::python::make_function(
+        .add_property( "minFilterSupported", make_function(
                 &This::IsMinFilterSupported,
-                boost::python::return_value_policy<boost::python::return_by_value>()))
+                return_value_policy<return_by_value>()))
 
-        .add_property( "magFilterSupported", boost::python::make_function(
+        .add_property( "magFilterSupported", make_function(
                 &This::IsMagFilterSupported,
-                boost::python::return_value_policy<boost::python::return_by_value>()))
+                return_value_policy<return_by_value>()))
         ;
 }
     
diff --git a/pxr/imaging/hd/unitTestDelegate.cpp b/pxr/imaging/hd/unitTestDelegate.cpp
index 1f687c6ef..1bb46a62f 100644
--- a/pxr/imaging/hd/unitTestDelegate.cpp
+++ b/pxr/imaging/hd/unitTestDelegate.cpp
@@ -595,8 +595,8 @@ HdUnitTestDelegate::UpdateRprims(float time)
         if (_FindPrimvar(id, HdTokens->displayColor, &pvIt)) {
             if (pvIt->interp == HdInterpolationConstant) {
                 GfVec4f color = pvIt->value.Get<GfVec4f>();
-                color[0] = std::fmod(color[0] + delta, 1.0f);
-                color[1] = std::fmod(color[1] + delta*2, 1.0f);    
+                color[0] = fmod(color[0] + delta, 1.0f);
+                color[1] = fmod(color[1] + delta*2, 1.0f);    
                 pvIt->value = VtValue(color);
             }
         }
@@ -1660,7 +1660,7 @@ HdUnitTestDelegate::AddPoints(
     VtVec3fArray points(numPoints);
     float s = 0, t = 0;
     for (int i = 0; i < numPoints; ++i) {
-        GfVec4f p (std::sin(s)*std::cos(t), std::sin(s)*std::sin(t), std::cos(s), 1);
+        GfVec4f p (sin(s)*cos(t), sin(s)*sin(t), cos(s), 1);
         p = p * transform;
         points[i] = GfVec3f(p[0], p[1], p[2]);;
         s += 0.10;
diff --git a/pxr/imaging/hdSt/light.cpp b/pxr/imaging/hdSt/light.cpp
index a20bc0282..b755b9abf 100644
--- a/pxr/imaging/hdSt/light.cpp
+++ b/pxr/imaging/hdSt/light.cpp
@@ -99,7 +99,7 @@ static GfVec3f _BlackbodyTemperatureAsRgb(float temp)
     // to simplify boundary behavior
     constexpr int numSegs = (numKnots-4);
     const float x = u_spline * numSegs;
-    const int seg = int(std::floor(x));
+    const int seg = int(floor(x));
     const float u_seg = x-seg; // Parameter within segment
     // Knot values for this segment
     GfVec3f k0 = _blackbodyRGB[seg+0];
diff --git a/pxr/imaging/hdSt/primUtils.cpp b/pxr/imaging/hdSt/primUtils.cpp
index 96e27ba64..9d13b36ea 100644
--- a/pxr/imaging/hdSt/primUtils.cpp
+++ b/pxr/imaging/hdSt/primUtils.cpp
@@ -1055,7 +1055,7 @@ _GetBitmaskEncodedVisibilityBuffer(VtIntArray invisibleIndices,
                                     SdfPath const& rprimId)
 {
     size_t numBitsPerUInt = std::numeric_limits<uint32_t>::digits; // i.e, 32
-    size_t numUIntsNeeded = std::ceil(numTotalIndices/(float) numBitsPerUInt);
+    size_t numUIntsNeeded = ceil(numTotalIndices/(float) numBitsPerUInt);
     // Initialize all bits to 1 (visible)
     VtArray<uint32_t> visibility(numUIntsNeeded,
                                  std::numeric_limits<uint32_t>::max());
diff --git a/pxr/imaging/hdSt/textureUtils.cpp b/pxr/imaging/hdSt/textureUtils.cpp
index ec010f169..18ca5ed34 100644
--- a/pxr/imaging/hdSt/textureUtils.cpp
+++ b/pxr/imaging/hdSt/textureUtils.cpp
@@ -85,7 +85,7 @@ float _ConvertColorSpace(const float in)
         if (in <= 0.0031308) {
             out = 12.92 * in;
         } else {
-            out = 1.055 * std::pow(in, 1.0 / 2.4) - 0.055;
+            out = 1.055 * pow(in, 1.0 / 2.4) - 0.055;
         }
     }
 
diff --git a/pxr/imaging/hdSt/volumeShader.cpp b/pxr/imaging/hdSt/volumeShader.cpp
index 6b571b1e9..616dd4a50 100644
--- a/pxr/imaging/hdSt/volumeShader.cpp
+++ b/pxr/imaging/hdSt/volumeShader.cpp
@@ -275,7 +275,7 @@ _ComputeSampleDistance(const GfBBox3d &bbox)
     const GfMatrix4d &m = bbox.GetMatrix();
 
     // Take minimum of lengths of images of the x-, y-, and z-vector.
-    return std::sqrt(
+    return sqrt(
         std::min({ _SqrLengthThreeVector(m[0]),
                    _SqrLengthThreeVector(m[1]),
                    _SqrLengthThreeVector(m[2]) }));
diff --git a/pxr/imaging/hio/dictionary.cpp b/pxr/imaging/hio/dictionary.cpp
index b8df6728b..807e3fecf 100644
--- a/pxr/imaging/hio/dictionary.cpp
+++ b/pxr/imaging/hio/dictionary.cpp
@@ -31,6 +31,7 @@
 PXR_NAMESPACE_OPEN_SCOPE
 
 
+using namespace std;
 
 
 TF_DEBUG_CODES(
@@ -48,8 +49,8 @@ TF_REGISTRY_FUNCTION(TfDebug)
 
 static VtDictionary
 _Hio_GetDictionaryFromJSON(
-    const std::string &input,
-    std::string *errorStr )
+    const string &input,
+    string *errorStr )
 {
     if (input.empty())
     {
@@ -112,9 +113,9 @@ _Hio_GetDictionaryFromJSON(
 
 VtDictionary
 Hio_GetDictionaryFromInput(
-    const std::string &input,
-    const std::string &filename,
-    std::string *errorStr )
+    const string &input,
+    const string &filename,
+    string *errorStr )
 {
     std::string jsError;
     VtDictionary ret = _Hio_GetDictionaryFromJSON(input, &jsError);
diff --git a/pxr/imaging/hio/glslfx.cpp b/pxr/imaging/hio/glslfx.cpp
index 6b7f5d249..22d29a1cd 100644
--- a/pxr/imaging/hio/glslfx.cpp
+++ b/pxr/imaging/hio/glslfx.cpp
@@ -53,6 +53,12 @@ TF_DEFINE_PUBLIC_TOKENS(HioGlslfxTokens, HIO_GLSLFX_TOKENS);
 
 #define CURRENT_VERSION 0.1
 
+using std::string;
+using std::vector;
+using std::list;
+using std::istringstream;
+using std::istream;
+using std::ifstream;
 
 TF_DEFINE_PRIVATE_TOKENS(
     _tokens,
@@ -66,6 +72,7 @@ TF_DEFINE_PRIVATE_TOKENS(
     ((toolSubst, "$TOOLS"))
 );
 
+using namespace std;
 
 namespace {
 
@@ -99,7 +106,7 @@ ShaderResourceRegistry::ShaderResourceRegistry()
         if (TfMapLookup(metadata, _tokens->shaderResources, &value)
                && value.Is<std::string>()) {
 
-            std::string shaderPath =
+            string shaderPath =
                 TfStringCatPaths(plugin->GetResourcePath(),
                                  value.Get<std::string>());
             _resourceMap[packageName] = shaderPath;
@@ -112,7 +119,7 @@ ShaderResourceRegistry::GetShaderResourcePath(
         std::string const & packageName,
         std::string const & shaderAssetPath) const
 {
-    std::string resourcePath;
+    string resourcePath;
     if (!TfMapLookup(_resourceMap, packageName, &resourcePath)) {
         return std::string();
     }
@@ -124,10 +131,10 @@ static TfStaticData<const ShaderResourceRegistry> _shaderResourceRegistry;
 
 };
 
-static std::string
-_ResolveResourcePath(const std::string& importFile, std::string *errorStr)
+static string
+_ResolveResourcePath(const string& importFile, string *errorStr)
 {
-    const std::vector<std::string> pathTokens = TfStringTokenize(importFile, "/");
+    const vector<string> pathTokens = TfStringTokenize(importFile, "/");
     if (pathTokens.size() < 3) {
         if( errorStr )
         {
@@ -138,12 +145,12 @@ _ResolveResourcePath(const std::string& importFile, std::string *errorStr)
         return "";
     }
 
-    const std::string packageName = pathTokens[1];
+    const string packageName = pathTokens[1];
 
-    const std::string assetPath = TfStringJoin(
-        std::vector<std::string>(pathTokens.begin() + 3, pathTokens.end()), "/");
+    const string assetPath = TfStringJoin(
+        vector<string>(pathTokens.begin() + 3, pathTokens.end()), "/");
 
-    const std::string resourcePath =
+    const string resourcePath =
         _shaderResourceRegistry->GetShaderResourcePath(packageName,
                                                         assetPath);
     if (resourcePath.empty() && errorStr) {
@@ -156,11 +163,11 @@ _ResolveResourcePath(const std::string& importFile, std::string *errorStr)
     return TfPathExists(resourcePath) ? resourcePath : ""; 
 }
 
-static std::string
+static string
 _ComputeResolvedPath(
-    const std::string &containingFile,
-    const std::string &filename,
-    std::string *errorStr )
+    const string &containingFile,
+    const string &filename,
+    string *errorStr )
 {
     // Resolve $TOOLS-prefixed paths.
     if (TfStringStartsWith(filename, _tokens->toolSubst.GetString() + "/")) {
@@ -201,7 +208,7 @@ _ComputeResolvedPath(
     // then resolve it.
     const std::string assetPath =
         resolver.CreateIdentifier(filename, ArResolvedPath(containingFile));
-    return assetPath.empty() ? std::string() : resolver.Resolve(assetPath);
+    return assetPath.empty() ? string() : resolver.Resolve(assetPath);
 #endif
 }
 
@@ -211,12 +218,12 @@ HioGlslfx::HioGlslfx() :
     // do nothing
 }
 
-HioGlslfx::HioGlslfx(std::string const & filePath, TfToken const & technique)
+HioGlslfx::HioGlslfx(string const & filePath, TfToken const & technique)
     : _technique(technique)
     , _valid(true)
     , _hash(0)
 {
-    std::string errorStr;
+    string errorStr;
 #if AR_VERSION == 1
     // Resolve with the containingFile set to the current working directory
     // with a trailing slash. This ensures that relative paths supplied to the
@@ -224,8 +231,8 @@ HioGlslfx::HioGlslfx(std::string const & filePath, TfToken const & technique)
     const string resolvedPath =
         _ComputeResolvedPath(ArchGetCwd() + "/", filePath, &errorStr);
 #else
-    const std::string resolvedPath =
-        _ComputeResolvedPath(std::string(), filePath, &errorStr);
+    const string resolvedPath =
+        _ComputeResolvedPath(string(), filePath, &errorStr);
 #endif
     if (resolvedPath.empty()) {
         if (!errorStr.empty()) {
@@ -249,7 +256,7 @@ HioGlslfx::HioGlslfx(std::string const & filePath, TfToken const & technique)
     }
 }
 
-HioGlslfx::HioGlslfx(std::istream &is, TfToken const & technique)
+HioGlslfx::HioGlslfx(istream &is, TfToken const & technique)
     : _globalContext("istream")
     , _technique(technique)
     , _valid(true)
@@ -273,20 +280,20 @@ HioGlslfx::IsValid(std::string *reason) const
     return _valid;
 }
 
-static std::unique_ptr<std::istream>
-_CreateStreamForFile(std::string const& filePath)
+static unique_ptr<istream>
+_CreateStreamForFile(string const& filePath)
 {
     if (TfIsFile(filePath)) {
-        return std::make_unique<std::ifstream>(filePath);
+        return make_unique<ifstream>(filePath);
     }
 
-    const std::shared_ptr<ArAsset> asset = ArGetResolver().OpenAsset(
+    const shared_ptr<ArAsset> asset = ArGetResolver().OpenAsset(
         ArResolvedPath(filePath));
     if (asset) {
-        const std::shared_ptr<const char> buffer = asset->GetBuffer();
+        const shared_ptr<const char> buffer = asset->GetBuffer();
         if (buffer) {
-            return std::make_unique<std::istringstream>(
-                std::string(buffer.get(), asset->GetSize()));
+            return make_unique<istringstream>(
+                string(buffer.get(), asset->GetSize()));
         }
     }
 
@@ -294,7 +301,7 @@ _CreateStreamForFile(std::string const& filePath)
 }
 
 bool
-HioGlslfx::_ProcessFile(std::string const & filePath, _ParseContext & context)
+HioGlslfx::_ProcessFile(string const & filePath, _ParseContext & context)
 {
     if (_seenFiles.count(filePath)) {
         // for now, just ignore files that have already been included
@@ -305,7 +312,7 @@ HioGlslfx::_ProcessFile(std::string const & filePath, _ParseContext & context)
 
     _seenFiles.insert(filePath);
 
-    const std::unique_ptr<std::istream> str = _CreateStreamForFile(filePath);
+    const unique_ptr<istream> str = _CreateStreamForFile(filePath);
     if (!str) {
         TF_RUNTIME_ERROR("Could not open %s", filePath.c_str());
         return false;
@@ -315,18 +322,18 @@ HioGlslfx::_ProcessFile(std::string const & filePath, _ParseContext & context)
 }
 
 // static
-std::vector<std::string>
-HioGlslfx::ExtractImports(const std::string& filename)
+vector<string>
+HioGlslfx::ExtractImports(const string& filename)
 {
-    const std::unique_ptr<std::istream> input = _CreateStreamForFile(filename);
+    const unique_ptr<istream> input = _CreateStreamForFile(filename);
     if (!input) {
         return {};
     }
 
-    std::vector<std::string> imports;
+    vector<string> imports;
 
-    std::string line;
-    while (std::getline(*input, line)) {
+    string line;
+    while (getline(*input, line)) {
         if (line.find(_tokens->import) == 0) {
             imports.push_back(TfStringTrim(line.substr(_tokens->import.size())));
         }
@@ -339,7 +346,7 @@ bool
 HioGlslfx::_ProcessInput(std::istream * input,
                          _ParseContext & context)
 {
-    while (std::getline(*input, context.currentLine)) {
+    while (getline(*input, context.currentLine)) {
         // trim to avoid issues with cross-platform line endings
         context.currentLine = TfStringTrimRight(context.currentLine);
 
@@ -412,7 +419,7 @@ HioGlslfx::_ProcessInput(std::istream * input,
 bool
 HioGlslfx::_ProcessImport(_ParseContext & context)
 {
-    const std::vector<std::string> tokens = TfStringTokenize(context.currentLine);
+    const vector<string> tokens = TfStringTokenize(context.currentLine);
 
     if (tokens.size() != 2) {
         TF_RUNTIME_ERROR("Syntax Error on line %d of %s. #import declaration "
@@ -421,8 +428,8 @@ HioGlslfx::_ProcessImport(_ParseContext & context)
         return false;
     }
 
-    std::string errorStr;
-    const std::string importFile = _ComputeResolvedPath(context.filename, tokens[1],
+    string errorStr;
+    const string importFile = _ComputeResolvedPath(context.filename, tokens[1],
                                                    &errorStr );
 
     if (importFile.empty()) {
@@ -446,7 +453,7 @@ bool
 HioGlslfx::_ParseSectionLine(_ParseContext & context)
 {
 
-    std::vector<std::string> tokens = TfStringTokenize(context.currentLine);
+    vector<string> tokens = TfStringTokenize(context.currentLine);
     if (tokens.size() == 1) {
         TF_RUNTIME_ERROR("Syntax Error on line %d of %s. Section delimiter "
                          "must be followed by a valid token.",
@@ -474,7 +481,7 @@ HioGlslfx::_ParseSectionLine(_ParseContext & context)
 }
 
 bool
-HioGlslfx::_ParseGLSLSectionLine(std::vector<std::string> const & tokens,
+HioGlslfx::_ParseGLSLSectionLine(vector<string> const & tokens,
                                   _ParseContext & context)
 {
     if (tokens.size() < 3) {
@@ -507,7 +514,7 @@ HioGlslfx::_ParseGLSLSectionLine(std::vector<std::string> const & tokens,
 }
 
 bool
-HioGlslfx::_ParseVersionLine(std::vector<std::string> const & tokens,
+HioGlslfx::_ParseVersionLine(vector<string> const & tokens,
                               _ParseContext & context)
 {
     if (context.lineNo != 1) {
@@ -587,7 +594,7 @@ HioGlslfx::_ComposeConfiguration(std::string *reason)
         TF_DEBUG(HIO_DEBUG_GLSLFX).Msg("    Parsing config for %s\n",
                                         TfGetBaseName(item).c_str());
 
-        std::string errorStr;
+        string errorStr;
         _config.reset(HioGlslfxConfig::Read(
             _technique, _configMap[item], item, &errorStr));
 
@@ -642,17 +649,17 @@ HioGlslfx::GetMetadata() const
     return HioGlslfxConfig::MetadataDictionary();
 }
 
-std::string
+string
 HioGlslfx::_GetSource(const TfToken &shaderStageKey) const
 {
     if (!_config) {
         return "";
     }
 
-    std::string errors;
-    std::vector<std::string> sourceKeys = _config->GetSourceKeys(shaderStageKey);
+    string errors;
+    vector<string> sourceKeys = _config->GetSourceKeys(shaderStageKey);
 
-    std::string ret;
+    string ret;
 
     for (std::string const& key : sourceKeys) {
         // now look up the keys and concatenate them together..
@@ -663,7 +670,7 @@ HioGlslfx::_GetSource(const TfToken &shaderStageKey) const
                              "<%s>",
                              shaderStageKey.GetText(),
                              key.c_str());
-            return std::string();
+            return string();
         }
 
         ret += cit->second + "\n";
@@ -672,25 +679,25 @@ HioGlslfx::_GetSource(const TfToken &shaderStageKey) const
     return ret;
 }
 
-std::string
+string
 HioGlslfx::GetSurfaceSource() const
 {
     return _GetSource(HioGlslfxTokens->surfaceShader);
 }
 
-std::string
+string
 HioGlslfx::GetDisplacementSource() const
 {
     return _GetSource(HioGlslfxTokens->displacementShader);
 }
 
-std::string
+string
 HioGlslfx::GetVolumeSource() const
 {
     return _GetSource(HioGlslfxTokens->volumeShader);
 }
 
-std::string
+string
 HioGlslfx::GetSource(const TfToken &shaderStageKey) const
 {
     return _GetSource(shaderStageKey);
diff --git a/pxr/imaging/hio/glslfxConfig.cpp b/pxr/imaging/hio/glslfxConfig.cpp
index 019dce7e3..5b7688168 100644
--- a/pxr/imaging/hio/glslfxConfig.cpp
+++ b/pxr/imaging/hio/glslfxConfig.cpp
@@ -34,6 +34,8 @@
 PXR_NAMESPACE_OPEN_SCOPE
 
 
+using std::string;
+using std::vector;
 
 TF_DEFINE_PRIVATE_TOKENS(
     _tokens,
@@ -205,9 +207,9 @@ _GetDefaultValue(
 
 HioGlslfxConfig *
 HioGlslfxConfig::Read(TfToken const & technique,
-                      std::string const & input,
-                      std::string const & filename,
-                      std::string *errorStr)
+                      string const & input,
+                      string const & filename,
+                      string *errorStr)
 {
     return new HioGlslfxConfig(technique,
         Hio_GetDictionaryFromInput(input, filename, errorStr), errorStr );
@@ -215,14 +217,14 @@ HioGlslfxConfig::Read(TfToken const & technique,
 
 HioGlslfxConfig::HioGlslfxConfig(TfToken const & technique,
                                  VtDictionary const & dict,
-                                 std::string * errors)
+                                 string * errors)
 : _technique(technique)
 {
     _Init(dict, errors);
 }
 
 void
-HioGlslfxConfig::_Init(VtDictionary const & dict, std::string * errors)
+HioGlslfxConfig::_Init(VtDictionary const & dict, string * errors)
 {
     TRACE_FUNCTION();
 
@@ -243,7 +245,7 @@ HioGlslfxConfig::GetSourceKeys(TfToken const & shaderStageKey) const
  
 HioGlslfxConfig::_SourceKeyMap
 HioGlslfxConfig::_GetSourceKeyMap(VtDictionary const & dict,
-                                   std::string *errorStr) const
+                                   string *errorStr) const
 {
     // XXX as we implement more public API for this thing, some better structure
     // in the internal API we use to access parts of this graph would
@@ -299,7 +301,7 @@ HioGlslfxConfig::_GetSourceKeyMap(VtDictionary const & dict,
     const VtDictionary& specDict = techniqueSpec.UncheckedGet<VtDictionary>();
     // get all of the shader stages specified in the spec
     for (const std::pair<std::string, VtValue>& p : specDict) {
-        const std::string& shaderStageKey = p.first;
+        const string& shaderStageKey = p.first;
         const VtValue& shaderStageSpec = p.second;
 
         // verify that the shaderStageSpec also holds a VtDictionary
@@ -324,7 +326,7 @@ HioGlslfxConfig::_GetSourceKeyMap(VtDictionary const & dict,
         }
 
         // verify that source holds a list
-        if (!source.IsHolding<std::vector<VtValue> >()) {
+        if (!source.IsHolding<vector<VtValue> >()) {
             *errorStr = TfStringPrintf("%s of %s for spec %s expects a list",
                                        _tokens->source.GetText(),
                                        shaderStageKey.c_str(),
@@ -332,10 +334,10 @@ HioGlslfxConfig::_GetSourceKeyMap(VtDictionary const & dict,
             return ret;
         }
 
-        std::vector<VtValue> sourceList = source.UncheckedGet<std::vector<VtValue>>();
+        vector<VtValue> sourceList = source.UncheckedGet<vector<VtValue>>();
         for (VtValue const& val : sourceList) {
             // verify that this value is a string
-            if (!val.IsHolding<std::string>()) {
+            if (!val.IsHolding<string>()) {
                 *errorStr = TfStringPrintf("%s of %s for spec %s expects a "
                                            "list of strings",
                                            _tokens->source.GetText(),
@@ -344,7 +346,7 @@ HioGlslfxConfig::_GetSourceKeyMap(VtDictionary const & dict,
                 return ret;
             }
 
-            ret[shaderStageKey].push_back(val.UncheckedGet<std::string>());
+            ret[shaderStageKey].push_back(val.UncheckedGet<string>());
         }
     }
 
@@ -352,7 +354,7 @@ HioGlslfxConfig::_GetSourceKeyMap(VtDictionary const & dict,
 }
 
 static HioGlslfxConfig::Role
-_GetRoleFromString(std::string const & roleString, std::string *errorStr)
+_GetRoleFromString(string const & roleString, string *errorStr)
 {
     if (roleString == _tokens->color) {
         return HioGlslfxConfig::RoleColor;
@@ -372,7 +374,7 @@ HioGlslfxConfig::GetParameters() const
 
 HioGlslfxConfig::Parameters
 HioGlslfxConfig::_GetParameters(VtDictionary const & dict, 
-                                 std::string *errorStr) const
+                                 string *errorStr) const
 {
     Parameters ret;
 
@@ -391,31 +393,31 @@ HioGlslfxConfig::_GetParameters(VtDictionary const & dict,
     }
 
     // look for the parameterOrder section: 
-    std::vector<std::string> paramOrder;
+    vector<string> paramOrder;
     VtValue paramOrderAny;
     TfMapLookup(dict, _tokens->parameterOrder, &paramOrderAny);
 
     if (!paramOrderAny.IsEmpty()) {
         // verify the type
-        if (!paramOrderAny.IsHolding<std::vector<VtValue> >()) {
+        if (!paramOrderAny.IsHolding<vector<VtValue> >()) {
             *errorStr =
                 TfStringPrintf("%s declaration expects a list of strings",
                                _tokens->parameterOrder.GetText());
             return ret;
         }
 
-        const std::vector<VtValue>& paramOrderList =
-            paramOrderAny.UncheckedGet<std::vector<VtValue> >();
+        const vector<VtValue>& paramOrderList =
+            paramOrderAny.UncheckedGet<vector<VtValue> >();
         for (VtValue const& val : paramOrderList) {
             // verify that this value is a string
-            if (!val.IsHolding<std::string>()) {
+            if (!val.IsHolding<string>()) {
                 *errorStr = TfStringPrintf("%s declaration expects a list of "
                                            "strings",
                                            _tokens->parameterOrder.GetText());
                 return ret;
             }
 
-            const std::string& paramName = val.UncheckedGet<std::string>();
+            const string& paramName = val.UncheckedGet<string>();
             if (std::find(paramOrder.begin(), paramOrder.end(), paramName) ==
                     paramOrder.end()) {
                 paramOrder.push_back(paramName);
@@ -427,7 +429,7 @@ HioGlslfxConfig::_GetParameters(VtDictionary const & dict,
     const VtDictionary& paramsDict = params.UncheckedGet<VtDictionary>();
     // pre-process the paramsDict in order to get the merged ordering
     for (const std::pair<std::string, VtValue>& p : paramsDict) {
-        std::string paramName = p.first;
+        string paramName = p.first;
         if (std::find(paramOrder.begin(), paramOrder.end(), paramName) ==
                 paramOrder.end()) {
             paramOrder.push_back(paramName);
@@ -466,9 +468,9 @@ HioGlslfxConfig::_GetParameters(VtDictionary const & dict,
 
         // optional documentation string
         VtValue docVal;
-        std::string docString;
+        string docString;
         if (TfMapLookup(paramDataDict, _tokens->documentation, &docVal)) {
-            if (!docVal.IsHolding<std::string>()) {
+            if (!docVal.IsHolding<string>()) {
                 *errorStr = TfStringPrintf("Value for %s for %s is not a "
                                            "string",
                                            _tokens->documentation.GetText(),
@@ -476,13 +478,13 @@ HioGlslfxConfig::_GetParameters(VtDictionary const & dict,
                 return ret;
             }
 
-            docString = docVal.UncheckedGet<std::string>();
+            docString = docVal.UncheckedGet<string>();
         }
         // optional role specification
         VtValue roleVal;
         Role role = RoleNone;
         if (TfMapLookup(paramDataDict, _tokens->role, &roleVal)) {
-            if (!roleVal.IsHolding<std::string>()) {
+            if (!roleVal.IsHolding<string>()) {
                 *errorStr = TfStringPrintf("Value for %s for %s is not a "
                                            "string",
                                            _tokens->role.GetText(),
@@ -490,7 +492,7 @@ HioGlslfxConfig::_GetParameters(VtDictionary const & dict,
                 return ret;
             }
 
-            const std::string& roleString = roleVal.UncheckedGet<std::string>();
+            const string& roleString = roleVal.UncheckedGet<string>();
             role = _GetRoleFromString(roleString, errorStr);
             if (!errorStr->empty()) {
                 return ret;
@@ -515,7 +517,7 @@ HioGlslfxConfig::GetTextures() const
 
 HioGlslfxConfig::Textures
 HioGlslfxConfig::_GetTextures(VtDictionary const & dict, 
-                               std::string *errorStr) const
+                               string *errorStr) const
 {
     Textures ret;
 
@@ -535,7 +537,7 @@ HioGlslfxConfig::_GetTextures(VtDictionary const & dict,
 
     const VtDictionary& texturesDict = textures.UncheckedGet<VtDictionary>();
     for (const std::pair<std::string, VtValue>& p : texturesDict) {
-        const std::string& textureName = p.first;
+        const string& textureName = p.first;
         const VtValue& textureData = p.second;
         if (!textureData.IsHolding<VtDictionary>()) {
             *errorStr = TfStringPrintf("%s declaration for %s expects a "
@@ -555,9 +557,9 @@ HioGlslfxConfig::_GetTextures(VtDictionary const & dict,
 
         // optional documentation string
         VtValue docVal;
-        std::string docString;
+        string docString;
         if (TfMapLookup(textureDataDict, _tokens->documentation, &docVal)) {
-            if (!docVal.IsHolding<std::string>()) {
+            if (!docVal.IsHolding<string>()) {
                 *errorStr = TfStringPrintf("Value for %s for %s is not a "
                                            "string",
                                            _tokens->documentation.GetText(),
@@ -565,7 +567,7 @@ HioGlslfxConfig::_GetTextures(VtDictionary const & dict,
                 return ret;
             }
 
-            docString = docVal.UncheckedGet<std::string>();
+            docString = docVal.UncheckedGet<string>();
         }
 
         TF_DEBUG(HIO_DEBUG_GLSLFX).Msg("        texture: %s\n",
@@ -585,7 +587,7 @@ HioGlslfxConfig::GetAttributes() const
 
 HioGlslfxConfig::Attributes
 HioGlslfxConfig::_GetAttributes(VtDictionary const & dict,
-                                 std::string *errorStr) const
+                                 string *errorStr) const
 {
     Attributes ret;
 
@@ -606,7 +608,7 @@ HioGlslfxConfig::_GetAttributes(VtDictionary const & dict,
     const VtDictionary& attributesDict =
         attributes.UncheckedGet<VtDictionary>();
     for (const std::pair<std::string, VtValue>& p : attributesDict) {
-        const std::string& attributeName = p.first;
+        const string& attributeName = p.first;
         const VtValue& attributeData = p.second;
         if (!attributeData.IsHolding<VtDictionary>()) {
             *errorStr = TfStringPrintf("%s declaration for %s expects a "
@@ -622,9 +624,9 @@ HioGlslfxConfig::_GetAttributes(VtDictionary const & dict,
 
         // optional documentation string
         VtValue docVal;
-        std::string docString;
+        string docString;
         if (TfMapLookup(attributeDataDict, _tokens->documentation, &docVal)) {
-            if (!docVal.IsHolding<std::string>()) {
+            if (!docVal.IsHolding<string>()) {
                 *errorStr = TfStringPrintf("Value for %s for %s is not a "
                                            "string",
                                            _tokens->documentation.GetText(),
@@ -632,7 +634,7 @@ HioGlslfxConfig::_GetAttributes(VtDictionary const & dict,
                 return ret;
             }
 
-            docString = docVal.UncheckedGet<std::string>();
+            docString = docVal.UncheckedGet<string>();
         }
 
         TF_DEBUG(HIO_DEBUG_GLSLFX).Msg("        attribute: %s\n",
@@ -657,7 +659,7 @@ HioGlslfxConfig::GetMetadata() const
 
 HioGlslfxConfig::MetadataDictionary
 HioGlslfxConfig::_GetMetadata(VtDictionary const & dict,
-                              std::string *errorStr) const
+                              string *errorStr) const
 {
     MetadataDictionary ret;
 
diff --git a/pxr/imaging/hio/stbImage.cpp b/pxr/imaging/hio/stbImage.cpp
index 74190d7db..61aff4336 100644
--- a/pxr/imaging/hio/stbImage.cpp
+++ b/pxr/imaging/hio/stbImage.cpp
@@ -160,7 +160,7 @@ Hio_StbImage::_GetFilenameExtension()
 {
     std::string fileExtension = ArGetResolver().GetExtension(_filename);
     //convert to lowercase
-    std::transform(fileExtension.begin(), 
+    transform(fileExtension.begin(), 
               fileExtension.end(), 
               fileExtension.begin(), ::tolower);
     return fileExtension;
@@ -328,12 +328,12 @@ Hio_StbImage::IsColorSpaceSRGB() const
     const float gamma_epsilon = 0.1f;
 
     // If we found gamma in the texture, use it to decide if we are sRGB
-    bool isSRGB = ( std::fabs(_gamma-0.45455f) < gamma_epsilon);
+    bool isSRGB = ( fabs(_gamma-0.45455f) < gamma_epsilon);
     if (isSRGB) {
         return true;
     }
 
-    bool isLinear = ( std::fabs(_gamma-1) < gamma_epsilon);
+    bool isLinear = ( fabs(_gamma-1) < gamma_epsilon);
     if (isLinear) {
         return false;
     }
diff --git a/pxr/imaging/plugin/hdEmbree/renderer.cpp b/pxr/imaging/plugin/hdEmbree/renderer.cpp
index 8727d3fcb..20ec78c6a 100644
--- a/pxr/imaging/plugin/hdEmbree/renderer.cpp
+++ b/pxr/imaging/plugin/hdEmbree/renderer.cpp
@@ -908,7 +908,7 @@ HdEmbreeRenderer::_ComputeColor(RTCRayHit const& rayHit,
     // Lighting model: (camera dot normal), i.e. diffuse-only point light
     // centered on the camera.
     GfVec3f dir = GfVec3f(rayHit.ray.dir_x, rayHit.ray.dir_y, rayHit.ray.dir_z);
-    float diffuseLight = std::fabs(GfDot(-dir, normal)) *
+    float diffuseLight = fabs(GfDot(-dir, normal)) *
         HdEmbreeConfig::GetInstance().cameraLightIntensity;
 
     // Lighting gets modulated by an ambient occlusion term.
diff --git a/pxr/imaging/pxOsd/wrapMeshTopology.cpp b/pxr/imaging/pxOsd/wrapMeshTopology.cpp
index daee8e102..dd4c9f52f 100644
--- a/pxr/imaging/pxOsd/wrapMeshTopology.cpp
+++ b/pxr/imaging/pxOsd/wrapMeshTopology.cpp
@@ -31,6 +31,7 @@
 
 #include <sstream>
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -57,30 +58,30 @@ void wrapMeshTopology()
     const PxOsdSubdivTags& (This::*getSubdivTags)() const =
         &This::GetSubdivTags;
 
-    boost::python::class_<This>("MeshTopology",
-                 boost::python::init<TfToken, TfToken, VtIntArray, VtIntArray>())
-        .def(boost::python::init<TfToken, TfToken, VtIntArray, VtIntArray, VtIntArray>())
-        .def(boost::python::init<TfToken, TfToken, VtIntArray, VtIntArray, VtIntArray, PxOsdSubdivTags>())
-        .def(boost::python::init<TfToken, TfToken, VtIntArray, VtIntArray, PxOsdSubdivTags>())
-        .def(boost::python::init<>())
+    class_<This>("MeshTopology",
+                 init<TfToken, TfToken, VtIntArray, VtIntArray>())
+        .def(init<TfToken, TfToken, VtIntArray, VtIntArray, VtIntArray>())
+        .def(init<TfToken, TfToken, VtIntArray, VtIntArray, VtIntArray, PxOsdSubdivTags>())
+        .def(init<TfToken, TfToken, VtIntArray, VtIntArray, PxOsdSubdivTags>())
+        .def(init<>())
         .def("__repr__", &::_ReprMeshTopology)
-        .def(boost::python::self == boost::python::self)
-        .def(boost::python::self != boost::python::self)
-        .def(boost::python::self_ns::str(boost::python::self))
+        .def(self == self)
+        .def(self != self)
+        .def(str(self))
 
         .def("GetScheme", &This::GetScheme)
         .def("WithScheme", &This::WithScheme)
         .def("GetFaceVertexCounts", &This::GetFaceVertexCounts,
-             boost::python::return_value_policy<boost::python::copy_const_reference>())
+             return_value_policy<copy_const_reference>())
         .def("GetFaceVertexIndices", &This::GetFaceVertexIndices,
-             boost::python::return_value_policy<boost::python::copy_const_reference>())
+             return_value_policy<copy_const_reference>())
         .def("GetOrientation", &This::GetOrientation,
-             boost::python::return_value_policy<boost::python::copy_const_reference>())
+             return_value_policy<copy_const_reference>())
         .def("GetHoleIndices", &This::GetHoleIndices,
-             boost::python::return_value_policy<boost::python::copy_const_reference>())
+             return_value_policy<copy_const_reference>())
         .def("WithHoleIndices", &This::WithHoleIndices)
         .def("GetSubdivTags", getSubdivTags,
-             boost::python::return_value_policy<boost::python::copy_const_reference>())
+             return_value_policy<copy_const_reference>())
         .def("WithSubdivTags", &This::WithSubdivTags)
         .def("ComputeHash", &This::ComputeHash)
         .def("Validate", &This::Validate)
diff --git a/pxr/imaging/pxOsd/wrapMeshTopologyValidation.cpp b/pxr/imaging/pxOsd/wrapMeshTopologyValidation.cpp
index 9038a9aad..01699ed46 100644
--- a/pxr/imaging/pxOsd/wrapMeshTopologyValidation.cpp
+++ b/pxr/imaging/pxOsd/wrapMeshTopologyValidation.cpp
@@ -37,6 +37,7 @@
 #include <sstream>
 #include <vector>
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -78,17 +79,17 @@ wrapMeshTopologyValidation()
 {
     using This = PxOsdMeshTopologyValidation;
 
-    boost::python::class_<This> cls("MeshTopologyValidation", boost::python::init<>());
-    cls.def(!boost::python::self);
+    class_<This> cls("MeshTopologyValidation", init<>());
+    cls.def(!self);
     {
-        boost::python::scope obj = cls;
+        scope obj = cls;
         TfPyWrapEnum<This::Code, true>();
-        boost::python::class_<This::Invalidation>("Invalidation", boost::python::no_init)
+        class_<This::Invalidation>("Invalidation", no_init)
             .def("__init__", &::_InvalidationInit)
             .def_readwrite("code", &This::Invalidation::code)
             .def_readwrite("message", &This::Invalidation::message)
             .def("__repr__", &::_InvalidationRepr);
     }
     cls.def("__repr__", &::_ValidationRepr);
-    cls.def("__iter__", boost::python::iterator<This>());
+    cls.def("__iter__", iterator<This>());
 }
diff --git a/pxr/imaging/pxOsd/wrapSubdivTags.cpp b/pxr/imaging/pxOsd/wrapSubdivTags.cpp
index 914417973..f351b3b05 100644
--- a/pxr/imaging/pxOsd/wrapSubdivTags.cpp
+++ b/pxr/imaging/pxOsd/wrapSubdivTags.cpp
@@ -31,6 +31,7 @@
 
 #include <sstream>
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -57,14 +58,14 @@ void wrapSubdivTags()
 {
     using This = PxOsdSubdivTags;
 
-    boost::python::class_<This>("SubdivTags", boost::python::init<>())
-        .def(boost::python::init<TfToken, TfToken, TfToken, TfToken,
+    class_<This>("SubdivTags", init<>())
+        .def(init<TfToken, TfToken, TfToken, TfToken,
                   VtIntArray, VtIntArray, VtFloatArray,
                   VtIntArray, VtFloatArray>())
         .def("__repr__", &::_ReprSubdivTags)
-        .def(boost::python::self == boost::python::self)
-        .def(boost::python::self != boost::python::self)
-        .def(boost::python::self_ns::str(boost::python::self))
+        .def(self == self)
+        .def(self != self)
+        .def(str(self))
 
         .def("GetVertexInterpolationRule", &This::GetVertexInterpolationRule)
         .def("SetVertexInterpolationRule", &This::SetVertexInterpolationRule)
@@ -77,19 +78,19 @@ void wrapSubdivTags()
         .def("GetTriangleSubdivision", &This::GetTriangleSubdivision)
         .def("SetTriangleSubdivision", &This::SetTriangleSubdivision)
         .def("GetCreaseIndices", &This::GetCreaseIndices,
-             boost::python::return_value_policy<boost::python::copy_const_reference>())
+             return_value_policy<copy_const_reference>())
         .def("SetCreaseIndices", &This::SetCreaseIndices)
         .def("GetCreaseLengths", &This::GetCreaseLengths,
-             boost::python::return_value_policy<boost::python::copy_const_reference>())
+             return_value_policy<copy_const_reference>())
         .def("SetCreaseLengths", &This::SetCreaseLengths)
         .def("GetCreaseWeights", &This::GetCreaseWeights,
-             boost::python::return_value_policy<boost::python::copy_const_reference>())
+             return_value_policy<copy_const_reference>())
         .def("SetCreaseWeights", &This::SetCreaseWeights)
         .def("GetCornerIndices", &This::GetCornerIndices,
-             boost::python::return_value_policy<boost::python::copy_const_reference>())
+             return_value_policy<copy_const_reference>())
         .def("SetCornerIndices", &This::SetCornerIndices)
         .def("GetCornerWeights", &This::GetCornerWeights,
-             boost::python::return_value_policy<boost::python::copy_const_reference>())
+             return_value_policy<copy_const_reference>())
         .def("SetCornerWeights", &This::SetCornerWeights)
         .def("ComputeHash", &This::ComputeHash)
     ;
diff --git a/pxr/usd/bin/sdfdump/sdfdump.cpp b/pxr/usd/bin/sdfdump/sdfdump.cpp
index 22bd37b73..bcb262224 100644
--- a/pxr/usd/bin/sdfdump/sdfdump.cpp
+++ b/pxr/usd/bin/sdfdump/sdfdump.cpp
@@ -45,10 +45,16 @@
 PXR_NAMESPACE_OPEN_SCOPE
 
 
+using std::string;
+using std::vector;
+using std::ostream;
+using std::pair;
+using std::unordered_map;
+using std::unordered_set;
 
 namespace {
 
-std::string progName;
+string progName;
 
 void VErr(char const *fmt, va_list ap) {
     fprintf(stderr, "%s: Error - %s\n", progName.c_str(),
@@ -81,28 +87,29 @@ bool IsClose(double a, double b, double tol)
 
 struct SortKey {
     SortKey() : key("path") {}
-    SortKey(std::string key) : key(key) {}
-    std::string key;
+    SortKey(string key) : key(key) {}
+    string key;
 };
-std::ostream &operator<<(std::ostream &os, SortKey const &sk) { return os << sk.key; }
+ostream &operator<<(ostream &os, SortKey const &sk) { return os << sk.key; }
 
 // boost::program_options calls validate() for custom argument types.
-void validate(boost::any& v, const std::vector<std::string> &values, SortKey*, int) {
-    boost::program_options::validators::check_first_occurrence(v);
-    std::string const &s = boost::program_options::validators::get_single_string(values);
+void validate(boost::any& v, const vector<string> &values, SortKey*, int) {
+    using namespace boost::program_options;
+    validators::check_first_occurrence(v);
+    string const &s = validators::get_single_string(values);
     if (s == "path" || s == "field") {
         v = SortKey(s);
     } else {
-        throw boost::program_options::validation_error(boost::program_options::validation_error::invalid_option_value);
+        throw validation_error(validation_error::invalid_option_value);
     }
 }
 
 // Parse times and time ranges in timeSpecs, throw an exception if something
 // goes wrong.
 void
-ParseTimes(std::vector<std::string> const &timeSpecs,
-           std::vector<double> *literalTimes,
-           std::vector<std::pair<double, double>> *timeRanges)
+ParseTimes(vector<string> const &timeSpecs,
+           vector<double> *literalTimes,
+           vector<pair<double, double>> *timeRanges)
 {
     for (auto const &spec: timeSpecs) {
         try {
@@ -123,11 +130,11 @@ ParseTimes(std::vector<std::string> const &timeSpecs,
                 TfStringPrintf("invalid time syntax '%s'", spec.c_str()));
         }
     }
-    std::sort(literalTimes->begin(), literalTimes->end());
-    literalTimes->erase(std::unique(literalTimes->begin(), literalTimes->end()),
+    sort(literalTimes->begin(), literalTimes->end());
+    literalTimes->erase(unique(literalTimes->begin(), literalTimes->end()),
                         literalTimes->end());
-    std::sort(timeRanges->begin(), timeRanges->end());
-    timeRanges->erase(std::unique(timeRanges->begin(), timeRanges->end()),
+    sort(timeRanges->begin(), timeRanges->end());
+    timeRanges->erase(unique(timeRanges->begin(), timeRanges->end()),
                       timeRanges->end());
 }
 
@@ -136,8 +143,8 @@ struct ReportParams
     TfPatternMatcher *pathMatcher = nullptr;
     TfPatternMatcher *fieldMatcher = nullptr;
     SortKey sortKey;
-    std::vector<double> literalTimes;
-    std::vector<std::pair<double, double>> timeRanges;
+    vector<double> literalTimes;
+    vector<pair<double, double>> timeRanges;
     double timeTolerance;
     bool showSummary = false;
     bool validate = false;
@@ -169,10 +176,10 @@ GetSummaryStats(SdfLayerHandle const &layer)
     return stats;
 }
 
-std::vector<SdfPath>
+vector<SdfPath>
 CollectPaths(SdfLayerHandle const &layer, ReportParams const &p)
 {
-    std::vector<SdfPath> result;
+    vector<SdfPath> result;
     layer->Traverse(SdfPath::AbsoluteRootPath(),
                     [&result, &p](SdfPath const &path) {
                         if (p.pathMatcher->Match(path.GetString()))
@@ -181,12 +188,12 @@ CollectPaths(SdfLayerHandle const &layer, ReportParams const &p)
     return result;
 }
 
-std::vector<TfToken>
+vector<TfToken>
 CollectFields(SdfLayerHandle const &layer, SdfPath const &path,
               ReportParams const &p)
 {
-    std::vector<TfToken> fields = layer->ListFields(path);
-    fields.erase(std::remove_if(fields.begin(), fields.end(),
+    vector<TfToken> fields = layer->ListFields(path);
+    fields.erase(remove_if(fields.begin(), fields.end(),
                            [&p](TfToken const &f) {
                                return !p.fieldMatcher->Match(f.GetString());
                            }),
@@ -194,7 +201,7 @@ CollectFields(SdfLayerHandle const &layer, SdfPath const &path,
     return fields;
 }
 
-std::string
+string
 GetValueString(VtValue const &value, ReportParams const &p)
 {
     return (!p.fullArrays && value.IsArrayValued()) ?
@@ -204,7 +211,7 @@ GetValueString(VtValue const &value, ReportParams const &p)
                        TfStringify(value).c_str());
 }
 
-std::string
+string
 GetTimeSamplesValueString(SdfLayerHandle const &layer,
                           SdfPath const &path, ReportParams const &p)
 {
@@ -213,7 +220,7 @@ GetTimeSamplesValueString(SdfLayerHandle const &layer,
     // for each sample, and format.
     bool takeAllTimes = p.literalTimes.empty() && p.timeRanges.empty();
     auto times = layer->ListTimeSamplesForPath(path);
-    std::vector<double> selectedTimes;
+    vector<double> selectedTimes;
     selectedTimes.reserve(times.size());
 
     if (takeAllTimes) {
@@ -222,7 +229,7 @@ GetTimeSamplesValueString(SdfLayerHandle const &layer,
     else {
         for (auto time: times) {
             // Check literalTimes.
-            auto rng = std::equal_range(
+            auto rng = equal_range(
                 p.literalTimes.begin(), p.literalTimes.end(), time,
                 [&p](double a, double b)  {
                     return IsClose(a, b, p.timeTolerance) ? false : a < b;
@@ -241,7 +248,7 @@ GetTimeSamplesValueString(SdfLayerHandle const &layer,
     if (selectedTimes.empty())
         return "<no samples at requested times>";
 
-    std::vector<std::string> result;
+    vector<string> result;
     VtValue val;
     for (auto time: selectedTimes) {
         TF_VERIFY(layer->QueryTimeSample(path, time, &val));
@@ -253,12 +260,12 @@ GetTimeSamplesValueString(SdfLayerHandle const &layer,
                           TfStringJoin(result, "\n        ").c_str());
 }
                           
-std::string
+string
 GetFieldValueString(SdfLayerHandle const &layer,
                     SdfPath const &path, TfToken const &field,
                     ReportParams const &p)
 {
-    std::string result;
+    string result;
     // Handle timeSamples specially:
     if (field == SdfFieldKeys->TimeSamples) {
         result = GetTimeSamplesValueString(layer, path, p);
@@ -272,10 +279,10 @@ GetFieldValueString(SdfLayerHandle const &layer,
 
 void
 GetReportByPath(SdfLayerHandle const &layer, ReportParams const &p,
-                std::vector<std::string> &report)
+                vector<string> &report)
 {
-    std::vector<SdfPath> paths = CollectPaths(layer, p);
-    std::sort(paths.begin(), paths.end());
+    vector<SdfPath> paths = CollectPaths(layer, p);
+    sort(paths.begin(), paths.end());
     for (auto const &path: paths) {
         SdfSpecType specType = layer->GetSpecType(path);
         report.push_back(
@@ -283,7 +290,7 @@ GetReportByPath(SdfLayerHandle const &layer, ReportParams const &p,
                 "<%s> : %s", 
                 path.GetText(), TfStringify(specType).c_str()));
 
-        std::vector<TfToken> fields = CollectFields(layer, path, p);
+        vector<TfToken> fields = CollectFields(layer, path, p);
         if (fields.empty())
             continue;
         for (auto const &field: fields) {
@@ -302,18 +309,18 @@ GetReportByPath(SdfLayerHandle const &layer, ReportParams const &p,
 
 void
 GetReportByField(SdfLayerHandle const &layer, ReportParams const &p,
-                 std::vector<std::string> &report)
+                 vector<string> &report)
 {
-    std::vector<SdfPath> paths = CollectPaths(layer, p);
-    std::unordered_map<std::string, std::vector<std::string>> pathsByFieldString;
-    std::unordered_set<std::string> allFieldStrings;
-    std::sort(paths.begin(), paths.end());
+    vector<SdfPath> paths = CollectPaths(layer, p);
+    unordered_map<string, vector<string>> pathsByFieldString;
+    unordered_set<string> allFieldStrings;
+    sort(paths.begin(), paths.end());
     for (auto const &path: paths) {
-        std::vector<TfToken> fields = CollectFields(layer, path, p);
+        vector<TfToken> fields = CollectFields(layer, path, p);
         if (fields.empty())
             continue;
         for (auto const &field: fields) {
-            std::string fieldString;
+            string fieldString;
             if (p.showValues) {
                 fieldString = TfStringPrintf(
                     "%s: %s", field.GetText(),
@@ -326,8 +333,8 @@ GetReportByField(SdfLayerHandle const &layer, ReportParams const &p,
             allFieldStrings.insert(fieldString);
         }
     }
-    std::vector<std::string> fsvec(allFieldStrings.begin(), allFieldStrings.end());
-    std::sort(fsvec.begin(), fsvec.end());
+    vector<string> fsvec(allFieldStrings.begin(), allFieldStrings.end());
+    sort(fsvec.begin(), fsvec.end());
 
     for (auto const &fs: fsvec) {
         report.push_back(fs);
@@ -339,12 +346,12 @@ GetReportByField(SdfLayerHandle const &layer, ReportParams const &p,
 
 void
 Validate(SdfLayerHandle const &layer, ReportParams const &p,
-         std::vector<std::string> &report)
+         vector<string> &report)
 {
     TfErrorMark m;
     TF_DESCRIBE_SCOPE("Collecting paths in @%s@",
                       layer->GetIdentifier().c_str());
-    std::vector<SdfPath> paths;
+    vector<SdfPath> paths;
     layer->Traverse(SdfPath::AbsoluteRootPath(),
                     [&paths, layer](SdfPath const &path) {
                         TF_DESCRIBE_SCOPE(
@@ -352,11 +359,11 @@ Validate(SdfLayerHandle const &layer, ReportParams const &p,
                             path.GetText(), layer->GetIdentifier().c_str());
                         paths.push_back(path);
                     });
-    std::sort(paths.begin(), paths.end());
+    sort(paths.begin(), paths.end());
     for (auto const &path: paths) {
         TF_DESCRIBE_SCOPE("Collecting fields for <%s> in @%s@",
                      path.GetText(), layer->GetIdentifier().c_str());
-        std::vector<TfToken> fields = layer->ListFields(path);
+        vector<TfToken> fields = layer->ListFields(path);
         if (fields.empty())
             continue;
         for (auto const &field: fields) {
@@ -390,7 +397,7 @@ Validate(SdfLayerHandle const &layer, ReportParams const &p,
 
 void Report(SdfLayerHandle layer, ReportParams const &p)
 {
-    std::vector<std::string> report = {
+    vector<string> report = {
         TfStringPrintf("@%s@", layer->GetIdentifier().c_str()) };
     if (p.showSummary) {
         auto stats = GetSummaryStats(layer);
@@ -420,6 +427,7 @@ PXR_NAMESPACE_CLOSE_SCOPE
 int
 main(int argc, char const *argv[])
 {
+    namespace po = boost::program_options;
     PXR_NAMESPACE_USING_DIRECTIVE
 
     progName = TfGetBaseName(argv[0]);
@@ -427,53 +435,53 @@ main(int argc, char const *argv[])
     bool showSummary = false, validate = false,
         fullArrays = false, noValues = false;
     SortKey sortKey("path");
-    std::string pathRegex = ".*", fieldRegex = ".*";
-    std::vector<std::string> timeSpecs, inputFiles;
-    std::vector<double> literalTimes;
-    std::vector<std::pair<double, double>> timeRanges;
+    string pathRegex = ".*", fieldRegex = ".*";
+    vector<string> timeSpecs, inputFiles;
+    vector<double> literalTimes;
+    vector<pair<double, double>> timeRanges;
     double timeTolerance = 1.25e-4; // ugh -- chosen to print well in help.
 
-    boost::program_options::options_description argOpts("Options");
+    po::options_description argOpts("Options");
     argOpts.add_options()
         ("help,h", "Show help message.")
-        ("summary,s", boost::program_options::bool_switch(&showSummary),
+        ("summary,s", po::bool_switch(&showSummary),
          "Report a high-level summary.")
-        ("validate", boost::program_options::bool_switch(&validate),
+        ("validate", po::bool_switch(&validate),
          "Check validity by trying to read all data values.")
-        ("path,p", boost::program_options::value<std::string>(&pathRegex)->value_name("regex"),
+        ("path,p", po::value<string>(&pathRegex)->value_name("regex"),
          "Report only paths matching this regex.")
-        ("field,f", boost::program_options::value<std::string>(&fieldRegex)->value_name("regex"),
+        ("field,f", po::value<string>(&fieldRegex)->value_name("regex"),
          "Report only fields matching this regex.")
-        ("time,t", boost::program_options::value<std::vector<std::string>>(&timeSpecs)->
+        ("time,t", po::value<vector<string>>(&timeSpecs)->
          multitoken()->value_name("n or ff..lf"),
          "Report only these times or time ranges for 'timeSamples' fields.")
-        ("timeTolerance", boost::program_options::value<double>(&timeTolerance)->
+        ("timeTolerance", po::value<double>(&timeTolerance)->
          default_value(timeTolerance)->value_name("tol"),
          "Report times that are close to those requested within this "
          "relative tolerance.")
-        ("sortBy", boost::program_options::value<SortKey>(&sortKey)->default_value(sortKey)->
+        ("sortBy", po::value<SortKey>(&sortKey)->default_value(sortKey)->
          value_name("path|field"),
          "Group output by either path or field.")
-        ("noValues", boost::program_options::bool_switch(&noValues),
+        ("noValues", po::bool_switch(&noValues),
          "Do not report field values.")
-        ("fullArrays", boost::program_options::bool_switch(&fullArrays),
+        ("fullArrays", po::bool_switch(&fullArrays),
          "Report full array contents rather than number of elements.")
         ;
 
-    boost::program_options::options_description inputFile("Input");
+    po::options_description inputFile("Input");
     inputFile.add_options()
-        ("input-file", boost::program_options::value<std::vector<std::string>>(&inputFiles), "input files");
+        ("input-file", po::value<vector<string>>(&inputFiles), "input files");
 
-    boost::program_options::options_description allOpts;
+    po::options_description allOpts;
     allOpts.add(argOpts).add(inputFile);
 
-    boost::program_options::variables_map vm;
+    po::variables_map vm;
     try {
-        boost::program_options::positional_options_description p;
+        po::positional_options_description p;
         p.add("input-file", -1);
-        boost::program_options::store(boost::program_options::command_line_parser(argc, argv).
+        po::store(po::command_line_parser(argc, argv).
                   options(allOpts).positional(p).run(), vm);
-        boost::program_options::notify(vm);
+        po::notify(vm);
         ParseTimes(timeSpecs, &literalTimes, &timeRanges);
     } catch (std::exception const &e) {
         ErrExit("%s", e.what());
diff --git a/pxr/usd/bin/sdffilter/sdffilter.cpp b/pxr/usd/bin/sdffilter/sdffilter.cpp
index 04f2206fa..c1bec31f5 100644
--- a/pxr/usd/bin/sdffilter/sdffilter.cpp
+++ b/pxr/usd/bin/sdffilter/sdffilter.cpp
@@ -57,6 +57,12 @@ ARCH_PRAGMA_POP
 
 PXR_NAMESPACE_OPEN_SCOPE
 
+using std::string;
+using std::vector;
+using std::ostream;
+using std::pair;
+using std::unordered_map;
+using std::unordered_set;
 
 // A file format for the human readable "pseudoLayer" output.  We use this so
 // that the terse human-readable output we produce is not a valid layer nor may
@@ -67,7 +73,7 @@ private:
     SDF_FILE_FORMAT_FACTORY_ACCESS;
 
 public:
-    SdfFilterPseudoFileFormat(std::string description="<< human readable >>")
+    SdfFilterPseudoFileFormat(string description="<< human readable >>")
         : SdfTextFileFormat(TfToken("pseudosdf"),
                             TfToken(description),
                             SdfTextFileFormatTokens->Target) {}
@@ -84,7 +90,7 @@ TF_REGISTRY_FUNCTION(TfType)
 namespace {
 
 // the basename of the executable.
-std::string progName;
+string progName;
 
 // print/error utilities.
 void VErr(char const *fmt, va_list ap) {
@@ -233,9 +239,9 @@ struct SummaryStats
 // Parse times and time ranges in timeSpecs, throw an exception if something
 // goes wrong.
 void
-ParseTimes(std::vector<std::string> const &timeSpecs,
-           std::vector<double> *literalTimes,
-           std::vector<std::pair<double, double>> *timeRanges)
+ParseTimes(vector<string> const &timeSpecs,
+           vector<double> *literalTimes,
+           vector<pair<double, double>> *timeRanges)
 {
     for (auto const &spec: timeSpecs) {
         try {
@@ -256,11 +262,11 @@ ParseTimes(std::vector<std::string> const &timeSpecs,
                 TfStringPrintf("invalid time syntax '%s'", spec.c_str()));
         }
     }
-    std::sort(literalTimes->begin(), literalTimes->end());
-    literalTimes->erase(std::unique(literalTimes->begin(), literalTimes->end()),
+    sort(literalTimes->begin(), literalTimes->end());
+    literalTimes->erase(unique(literalTimes->begin(), literalTimes->end()),
                         literalTimes->end());
-    std::sort(timeRanges->begin(), timeRanges->end());
-    timeRanges->erase(std::unique(timeRanges->begin(), timeRanges->end()),
+    sort(timeRanges->begin(), timeRanges->end());
+    timeRanges->erase(unique(timeRanges->begin(), timeRanges->end()),
                       timeRanges->end());
 }
 
@@ -286,7 +292,7 @@ CollectMatchingFields(SdfLayerHandle const &layer,
                       TfPatternMatcher const *matcher)
 {
     std::vector<TfToken> fields = layer->ListFields(path);
-    fields.erase(std::remove_if(fields.begin(), fields.end(),
+    fields.erase(remove_if(fields.begin(), fields.end(),
                            [&matcher](TfToken const &f) {
                                return matcher && !matcher->Match(f.GetString());
                            }),
@@ -339,7 +345,7 @@ GetReportTimeSamplesValue(SdfLayerHandle const &layer,
     else {
         for (auto time: times) {
             // Check literalTimes.
-            auto rng = std::equal_range(
+            auto rng = equal_range(
                 p.literalTimes.begin(), p.literalTimes.end(), time,
                 [&p](double a, double b)  {
                     return IsClose(a, b, p.timeTolerance) ? false : a < b;
@@ -409,7 +415,7 @@ GetReportByPath(SdfLayerHandle const &layer,
 {
     std::vector<SdfPath> paths =
         CollectMatchingSpecPaths(layer, p.pathMatcher.get());
-    std::sort(paths.begin(), paths.end());
+    sort(paths.begin(), paths.end());
     for (auto const &path: paths) {
         SdfSpecType specType = layer->GetSpecType(path);
         report.push_back(
@@ -447,7 +453,7 @@ GetReportByField(SdfLayerHandle const &layer,
     std::unordered_map<
         std::string, std::vector<std::string>> pathsByFieldString;
     std::unordered_set<std::string> allFieldStrings;
-    std::sort(paths.begin(), paths.end());
+    sort(paths.begin(), paths.end());
     for (auto const &path: paths) {
         std::vector<TfToken> fields =
             CollectMatchingFields(layer, path, p.fieldMatcher.get());
@@ -470,7 +476,7 @@ GetReportByField(SdfLayerHandle const &layer,
     }
     std::vector<std::string>
         fsvec(allFieldStrings.begin(), allFieldStrings.end());
-    std::sort(fsvec.begin(), fsvec.end());
+    sort(fsvec.begin(), fsvec.end());
 
     for (auto const &fs: fsvec) {
         report.push_back(fs);
@@ -504,6 +510,7 @@ FilterLayer(SdfLayerHandle const &inLayer,
             SdfLayerHandle const &outLayer,
             ReportParams const &p)
 {
+    namespace ph = std::placeholders;
     auto copyValueFn = [&p](
         SdfSpecType specType, TfToken const &field,
         SdfLayerHandle const &srcLayer, const SdfPath& srcPath, bool fieldInSrc,
@@ -520,7 +527,7 @@ FilterLayer(SdfLayerHandle const &inLayer,
         }
     };
 
-    std::vector<SdfPath> paths =
+    vector<SdfPath> paths =
         CollectMatchingSpecPaths(inLayer, p.pathMatcher.get());
     for (auto const &path: paths) {
         if (path == SdfPath::AbsoluteRootPath() ||
@@ -530,8 +537,8 @@ FilterLayer(SdfLayerHandle const &inLayer,
                         copyValueFn,
                         std::bind(SdfShouldCopyChildren,
                                   std::cref(path), std::cref(path),
-                                  std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5,
-                                  std::placeholders::_6, std::placeholders::_7, std::placeholders::_8, std::placeholders::_9));
+                                  ph::_1, ph::_2, ph::_3, ph::_4, ph::_5,
+                                  ph::_6, ph::_7, ph::_8, ph::_9));
         }
     }
 }
@@ -539,12 +546,12 @@ FilterLayer(SdfLayerHandle const &inLayer,
 // Attempt to validate a layer by reading all field values from all paths.
 void
 Validate(SdfLayerHandle const &layer, ReportParams const &p,
-         std::string &report)
+         string &report)
 {
     TfErrorMark m;
     TF_DESCRIBE_SCOPE("Collecting paths in @%s@",
                       layer->GetIdentifier().c_str());
-    std::vector<SdfPath> paths;
+    vector<SdfPath> paths;
     layer->Traverse(SdfPath::AbsoluteRootPath(),
                     [&paths, layer](SdfPath const &path) {
                         TF_DESCRIBE_SCOPE(
@@ -552,11 +559,11 @@ Validate(SdfLayerHandle const &layer, ReportParams const &p,
                             path.GetText(), layer->GetIdentifier().c_str());
                         paths.push_back(path);
                     });
-    std::sort(paths.begin(), paths.end());
+    sort(paths.begin(), paths.end());
     for (auto const &path: paths) {
         TF_DESCRIBE_SCOPE("Collecting fields for <%s> in @%s@",
                      path.GetText(), layer->GetIdentifier().c_str());
-        std::vector<TfToken> fields = layer->ListFields(path);
+        vector<TfToken> fields = layer->ListFields(path);
         if (fields.empty())
             continue;
         for (auto const &field: fields) {
@@ -608,7 +615,7 @@ struct OutputFile
             _file.reset(stdout);
         }
     }
-    void Write(std::string const &text) const {
+    void Write(string const &text) const {
         fputs(text.c_str(), _file.get());
     }
     std::unique_ptr<FILE, Closer> _file;
@@ -639,7 +646,7 @@ void Process(SdfLayerHandle layer, ReportParams const &p)
                 stats.numFields, stats.numSampleTimes));
     }
     else if (p.outputType == OutputOutline) {
-        std::vector<std::string> report;
+        vector<string> report;
         if (p.sortKey == SortByPath) {
             GetReportByPath(layer, p, report);
         }
@@ -671,7 +678,7 @@ void Process(SdfLayerHandle layer, ReportParams const &p)
             outputLayer = !p.outputFile.empty() ?
                 SdfLayer::CreateNew(p.outputFile, formatArgs) :
                 SdfLayer::CreateAnonymous(
-                    p.outputFormat.empty() ? std::string() :
+                    p.outputFormat.empty() ? string() :
                     TfStringPrintf(".%s", p.outputFormat.c_str()));
         }
 
@@ -680,7 +687,7 @@ void Process(SdfLayerHandle layer, ReportParams const &p)
 
         // If this layer is anonymous, it means we're writing to stdout.
         if (outputLayer->IsAnonymous()) {
-            std::string txt;
+            string txt;
             outputLayer->ExportToString(&txt);
             output.Write(txt);
         } else {
@@ -696,57 +703,58 @@ PXR_NAMESPACE_CLOSE_SCOPE
 int
 main(int argc, char const *argv[])
 {
+    namespace po = boost::program_options;
     PXR_NAMESPACE_USING_DIRECTIVE
 
     progName = TfGetBaseName(argv[0]);
 
-    std::string pathRegex = ".*", fieldRegex = ".*";
+    string pathRegex = ".*", fieldRegex = ".*";
     OutputType outputType = OutputOutline;
-    std::string outputFile, outputFormat;
-    std::vector<std::string> timeSpecs;
-    std::vector<std::string> inputFiles;
-    std::vector<double> literalTimes;
-    std::vector<std::pair<double, double>> timeRanges;
+    string outputFile, outputFormat;
+    vector<string> timeSpecs;
+    vector<string> inputFiles;
+    vector<double> literalTimes;
+    vector<pair<double, double>> timeRanges;
     double timeTolerance = 1.25e-4; // ugh -- chosen to print well in help.
     SortKey sortKey = SortByPath;
     int64_t arraySizeLimit = -2;
     int64_t timeSamplesSizeLimit = -2;
     bool noValues = false;
 
-    boost::program_options::options_description argOpts("Options");
+    po::options_description argOpts("Options");
     argOpts.add_options()
         ("help,h", "Show help message.")
-        ("path,p", boost::program_options::value<std::string>(&pathRegex)->value_name("regex"),
+        ("path,p", po::value<string>(&pathRegex)->value_name("regex"),
          "Report only paths matching this regex.  For 'layer' and "
          "'pseudoLayer' output types, include all descendants of matching "
          "paths.")
-        ("field,f", boost::program_options::value<std::string>(&fieldRegex)->value_name("regex"),
+        ("field,f", po::value<string>(&fieldRegex)->value_name("regex"),
          "Report only fields matching this regex.")
-        ("time,t", boost::program_options::value<std::vector<std::string>>(&timeSpecs)->
+        ("time,t", po::value<vector<string>>(&timeSpecs)->
          multitoken()->value_name("n or ff..lf"),
          "Report only these times or time ranges for 'timeSamples' fields.")
-        ("timeTolerance", boost::program_options::value<double>(&timeTolerance)->
+        ("timeTolerance", po::value<double>(&timeTolerance)->
          default_value(timeTolerance)->value_name("tol"),
          "Report times that are close to those requested within this "
          "relative tolerance.")
-        ("arraySizeLimit", boost::program_options::value<int64_t>(&arraySizeLimit)->value_name("N"),
+        ("arraySizeLimit", po::value<int64_t>(&arraySizeLimit)->value_name("N"),
          "Truncate arrays with more than this many elements.  If -1, do not "
          "truncate arrays.  Default: 0 for 'outline' output, 8 for "
          "'pseudoLayer' output, and -1 for 'layer' output.")
         ("timeSamplesSizeLimit",
-         boost::program_options::value<int64_t>(&timeSamplesSizeLimit)->value_name("N"),
+         po::value<int64_t>(&timeSamplesSizeLimit)->value_name("N"),
          "Truncate timeSamples with more than this many values.  If -1, do not "
          "truncate timeSamples.  Default: 0 for 'outline' output, 8 for "
          "'pseudoLayer' output, and -1 for 'layer' output.  Truncation "
          "performed after initial filtering by --time arguments.")
         ("out,o",
-         boost::program_options::value<std::string>(&outputFile)->default_value(std::string())->
+         po::value<string>(&outputFile)->default_value(std::string())->
          value_name("outputFile"),
          "Direct output to this file.  Use the "
          "'outputFormat' for finer control over the underlying format for "
          "output formats that are not uniquely determined by file extension.")
         ("outputType",
-         boost::program_options::value<OutputType>(&outputType)->default_value(outputType)->
+         po::value<OutputType>(&outputType)->default_value(outputType)->
          value_name("validity|summary|outline|pseudoLayer|layer"),
          "Specify output format; 'summary' reports overall statistics, "
          "'outline' is a flat text report of paths and fields, "
@@ -755,33 +763,33 @@ main(int argc, char const *argv[])
          "true layer output, with the format controlled by the 'outputFile' "
          "and 'outputFormat' arguments.")
         ("outputFormat",
-         boost::program_options::value<std::string>(&outputFormat)->value_name("format"),
+         po::value<string>(&outputFormat)->value_name("format"),
          "Supply this as the 'format' entry of SdfFileFormatArguments for "
          "'layer' output to a file.  Requires both 'layer' output and a "
          "specified 'outputFile'.")
-        ("sortBy", boost::program_options::value<SortKey>(&sortKey)->default_value(sortKey)->
+        ("sortBy", po::value<SortKey>(&sortKey)->default_value(sortKey)->
          value_name("path|field"),
          "Group 'outline' output by either path or field.  Ignored for other "
          "output types.")
-        ("noValues", boost::program_options::bool_switch(&noValues),
+        ("noValues", po::bool_switch(&noValues),
          "Do not report field values for 'outline' output.  Ignored for other "
          "output types.")
         ;
 
-    boost::program_options::options_description inputFile("Input");
+    po::options_description inputFile("Input");
     inputFile.add_options()
-        ("input-file", boost::program_options::value<std::vector<std::string>>(&inputFiles), "input files");
+        ("input-file", po::value<vector<string>>(&inputFiles), "input files");
 
-    boost::program_options::options_description allOpts;
+    po::options_description allOpts;
     allOpts.add(argOpts).add(inputFile);
 
-    boost::program_options::variables_map vm;
+    po::variables_map vm;
     try {
-        boost::program_options::positional_options_description p;
+        po::positional_options_description p;
         p.add("input-file", -1);
-        boost::program_options::store(boost::program_options::command_line_parser(argc, argv).
+        po::store(po::command_line_parser(argc, argv).
                   options(allOpts).positional(p).run(), vm);
-        boost::program_options::notify(vm);
+        po::notify(vm);
         ParseTimes(timeSpecs, &literalTimes, &timeRanges);
     } catch (std::exception const &e) {
         ErrExit("%s", e.what());
diff --git a/pxr/usd/pcp/mapFunction.h b/pxr/usd/pcp/mapFunction.h
index edfb1c2bd..d4e0fbd50 100644
--- a/pxr/usd/pcp/mapFunction.h
+++ b/pxr/usd/pcp/mapFunction.h
@@ -258,7 +258,7 @@ private:
                 }
             }
             else {
-                remotePairs.~std::shared_ptr<PathPair>();
+                remotePairs.~shared_ptr<PathPair>();
             }
         }
 
diff --git a/pxr/usd/pcp/wrapCache.cpp b/pxr/usd/pcp/wrapCache.cpp
index 744f84f56..b74849ebb 100644
--- a/pxr/usd/pcp/wrapCache.cpp
+++ b/pxr/usd/pcp/wrapCache.cpp
@@ -110,7 +110,7 @@ _ComputePropertyIndex( PcpCache &cache, const SdfPath &path )
 {
     PcpErrorVector errors;
     const PcpPropertyIndex &result = cache.ComputePropertyIndex(path, &errors);
-    boost::python::apply<PcpPropertyIndex>::type converter;
+    boost::python::return_by_value::apply<PcpPropertyIndex>::type converter;
     return boost::python::make_tuple(
         boost::python::object(boost::python::handle<>(converter(result))), 
         errors);
diff --git a/pxr/usd/plugin/sdrOsl/wrapOslParser.cpp b/pxr/usd/plugin/sdrOsl/wrapOslParser.cpp
index b56d0d759..f371ea64e 100644
--- a/pxr/usd/plugin/sdrOsl/wrapOslParser.cpp
+++ b/pxr/usd/plugin/sdrOsl/wrapOslParser.cpp
@@ -30,6 +30,7 @@
 
 #include <boost/python.hpp>
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -49,10 +50,10 @@ void wrapOslParser()
 {
     typedef SdrOslParserPlugin This;
 
-    boost::python::return_value_policy<boost::python::copy_const_reference> copyRefPolicy;
+    return_value_policy<copy_const_reference> copyRefPolicy;
 
-    boost::python::class_<This, boost::noncopyable>("OslParser")
-        .def("Parse", &_Parse, boost::python::return_value_policy<boost::python::manage_new_object>())
+    class_<This, boost::noncopyable>("OslParser")
+        .def("Parse", &_Parse, return_value_policy<manage_new_object>())
         .def("GetDiscoveryTypes", &This::GetDiscoveryTypes, copyRefPolicy)
         .def("GetSourceType", &This::GetSourceType, copyRefPolicy)
         ;
diff --git a/pxr/usd/plugin/usdAbc/alembicFileFormat.cpp b/pxr/usd/plugin/usdAbc/alembicFileFormat.cpp
index 88ec79cf9..14fed2c80 100644
--- a/pxr/usd/plugin/usdAbc/alembicFileFormat.cpp
+++ b/pxr/usd/plugin/usdAbc/alembicFileFormat.cpp
@@ -42,6 +42,7 @@
 PXR_NAMESPACE_OPEN_SCOPE
 
 
+using std::string;
 
 TF_DEFINE_PUBLIC_TOKENS(
     UsdAbcAlembicFileFormatTokens, 
@@ -74,7 +75,7 @@ UsdAbcAlembicFileFormat::InitData(const FileFormatArguments& args) const
 }
 
 bool
-UsdAbcAlembicFileFormat::CanRead(const std::string& filePath) const
+UsdAbcAlembicFileFormat::CanRead(const string& filePath) const
 {
     // XXX: Add more verification of file header magic
     auto extension = TfGetExtension(filePath);
@@ -88,7 +89,7 @@ UsdAbcAlembicFileFormat::CanRead(const std::string& filePath) const
 bool
 UsdAbcAlembicFileFormat::Read(
     SdfLayer* layer,
-    const std::string& resolvedPath,
+    const string& resolvedPath,
     bool metadataOnly) const
 {
     TRACE_FUNCTION();
diff --git a/pxr/usd/plugin/usdAbc/alembicReader.cpp b/pxr/usd/plugin/usdAbc/alembicReader.cpp
index a30509ed2..665325f3a 100644
--- a/pxr/usd/plugin/usdAbc/alembicReader.cpp
+++ b/pxr/usd/plugin/usdAbc/alembicReader.cpp
@@ -2287,7 +2287,7 @@ _CopyGenericValue(const AlembicType& src)
 template <class AlembicTraits, class UsdType>
 static
 VtValue
-_CopyGenericValue(const std::shared_ptr<TypedArraySample<AlembicTraits> >& src)
+_CopyGenericValue(const shared_ptr<TypedArraySample<AlembicTraits> >& src)
 {
     typedef typename PODTraitsFromEnum<
         AlembicTraits::pod_enum>::value_type SrcType;
diff --git a/pxr/usd/plugin/usdAbc/alembicWriter.cpp b/pxr/usd/plugin/usdAbc/alembicWriter.cpp
index 841605ae0..db5d172f3 100644
--- a/pxr/usd/plugin/usdAbc/alembicWriter.cpp
+++ b/pxr/usd/plugin/usdAbc/alembicWriter.cpp
@@ -368,26 +368,26 @@ UsdSamples::TakeSamples(SdfTimeSampleMap& samples)
 class _Parent {
 public:
     /// Construct invalid parent.
-    _Parent() : _object(new _Prim(std::shared_ptr<OObject>(new OObject))) { }
+    _Parent() : _object(new _Prim(shared_ptr<OObject>(new OObject))) { }
 
     /// Construct from an Alembic shared pointer to an OObject subclass.
     template <class T>
-    _Parent(const std::shared_ptr<T>& prim) :
+    _Parent(const shared_ptr<T>& prim) :
         _object(new _Prim(static_pointer_cast<OObject>(prim))) { }
 
     /// Construct from an Alembic shared pointer to a supported
     /// schema based OSchemaObject.
-    _Parent(const std::shared_ptr<OCamera>& prim):
+    _Parent(const shared_ptr<OCamera>& prim):
         _object(new _GeomPrim<OCamera>(prim)) { }
-    _Parent(const std::shared_ptr<OCurves>& prim):
+    _Parent(const shared_ptr<OCurves>& prim):
         _object(new _GeomPrim<OCurves>(prim)) { }
-    _Parent(const std::shared_ptr<OPoints>& prim):
+    _Parent(const shared_ptr<OPoints>& prim):
         _object(new _GeomPrim<OPoints>(prim)) { }
-    _Parent(const std::shared_ptr<OPolyMesh>& prim):
+    _Parent(const shared_ptr<OPolyMesh>& prim):
         _object(new _GeomPrim<OPolyMesh>(prim)) { }
-    _Parent(const std::shared_ptr<OSubD>& prim):
+    _Parent(const shared_ptr<OSubD>& prim):
         _object(new _GeomPrim<OSubD>(prim)) { }
-    _Parent(const std::shared_ptr<OXform>& prim):
+    _Parent(const shared_ptr<OXform>& prim):
         _object(new _GeomPrim<OXform>(prim)) { }
 
     /// Returns the OObject.
@@ -410,21 +410,21 @@ public:
 private:
     class _Prim {
     public:
-        explicit _Prim(const std::shared_ptr<OObject>& object) : _object(object) { }
+        explicit _Prim(const shared_ptr<OObject>& object) : _object(object) { }
         virtual ~_Prim();
-        const std::shared_ptr<OObject>& GetObjectPtr() const { return _object; }
+        const shared_ptr<OObject>& GetObjectPtr() const { return _object; }
         virtual OCompoundProperty GetSchema() const;
         virtual OCompoundProperty GetArbGeomParams() const;
         virtual OCompoundProperty GetUserProperties() const;
 
     private:
-        std::shared_ptr<OObject> _object;
+        shared_ptr<OObject> _object;
     };
 
     template <class T>
     class _GeomPrim : public _Prim {
     public:
-        explicit _GeomPrim(const std::shared_ptr<T>& object) : _Prim(object) { }
+        explicit _GeomPrim(const shared_ptr<T>& object) : _Prim(object) { }
         virtual ~_GeomPrim() { }
         virtual OCompoundProperty GetSchema() const;
         virtual OCompoundProperty GetArbGeomParams() const;
@@ -432,7 +432,7 @@ private:
     };
 
 private:
-    std::shared_ptr<_Prim> _object;
+    shared_ptr<_Prim> _object;
 };
 
 _Parent::_Prim::~_Prim()
@@ -961,7 +961,7 @@ private:
         UsdSamples result = _ExtractSamples(name);
         if (!result.IsEmpty() && !types.empty()) {
             SdfValueTypeName resultTypeName = result.GetTypeName();
-            if (std::find(types.begin(), types.end(), resultTypeName) ==
+            if (find(types.begin(), types.end(), resultTypeName) ==
                 types.end())
             {
                 TF_WARN("Property '%s' did not have expected type (got '%s')",
@@ -2470,7 +2470,7 @@ void
 _WriteRoot(_PrimWriterContext* context)
 {
     // Create the Alembic root.
-    std::shared_ptr<OObject> root(new OObject(context->GetArchive(), kTop));
+    shared_ptr<OObject> root(new OObject(context->GetArchive(), kTop));
     context->SetParent(root);
 
     // Make the root metadata.
@@ -2547,7 +2547,7 @@ _WriteCameraParameters(_PrimWriterContext* context)
     typedef OCamera Type;
 
     // Create the object and make it the parent.
-    std::shared_ptr<Type> object(new Type(context->GetParent(),
+    shared_ptr<Type> object(new Type(context->GetParent(),
                                      context->GetAlembicPrimName(),
                                      _GetPrimMetadata(*context)));
     context->SetParent(object);
@@ -2676,7 +2676,7 @@ _WriteUnknown(_PrimWriterContext* context)
     }
 
     // Create the object and make it the parent.
-    std::shared_ptr<Type> object(new Type(context->GetParent(),
+    shared_ptr<Type> object(new Type(context->GetParent(),
                                      context->GetAlembicPrimName(),
                                      metadata));
     context->SetParent(object);
@@ -2797,7 +2797,7 @@ _WritePolyMesh(_PrimWriterContext* context)
     const _WriterSchema& schema = context->GetSchema();
 
     // Create the object and make it the parent.
-    std::shared_ptr<Type> object(new Type(context->GetParent(),
+    shared_ptr<Type> object(new Type(context->GetParent(),
                                      context->GetAlembicPrimName(),
                                      _GetPrimMetadata(*context)));
     context->SetParent(object);
@@ -2904,7 +2904,7 @@ _WriteFaceSet(_PrimWriterContext* context)
     const _WriterSchema& schema = context->GetSchema();
 
     // Create the object and make it the parent.
-    std::shared_ptr<Type> object(new Type(context->GetParent(),
+    shared_ptr<Type> object(new Type(context->GetParent(),
                                      context->GetAlembicPrimName(),
                                      _GetPrimMetadata(*context)));
     context->SetParent(object);
@@ -2985,7 +2985,7 @@ _WriteSubD(_PrimWriterContext* context)
     const _WriterSchema& schema = context->GetSchema();
 
     // Create the object and make it the parent.
-    std::shared_ptr<Type> object(new Type(context->GetParent(),
+    shared_ptr<Type> object(new Type(context->GetParent(),
                                      context->GetAlembicPrimName(),
                                      _GetPrimMetadata(*context)));
     context->SetParent(object);
@@ -3155,7 +3155,7 @@ _WriteNurbsCurves(_PrimWriterContext* context)
     const _WriterSchema& schema = context->GetSchema();
 
     // Create the object and make it the parent.
-    std::shared_ptr<Type> object(new Type(context->GetParent(),
+    shared_ptr<Type> object(new Type(context->GetParent(),
                                      context->GetAlembicPrimName(),
                                      _GetPrimMetadata(*context)));
     context->SetParent(object);
@@ -3246,7 +3246,7 @@ _WriteBasisCurves(_PrimWriterContext* context)
     const _WriterSchema& schema = context->GetSchema();
 
     // Create the object and make it the parent.
-    std::shared_ptr<Type> object(new Type(context->GetParent(),
+    shared_ptr<Type> object(new Type(context->GetParent(),
                                      context->GetAlembicPrimName(),
                                      _GetPrimMetadata(*context)));
     context->SetParent(object);
@@ -3339,7 +3339,7 @@ _WriteHermiteCurves(_PrimWriterContext* context)
     const _WriterSchema& schema = context->GetSchema();
 
     // Create the object and make it the parent.
-    std::shared_ptr<Type> object(new Type(context->GetParent(),
+    shared_ptr<Type> object(new Type(context->GetParent(),
                                      context->GetAlembicPrimName(),
                                      _GetPrimMetadata(*context)));
     context->SetParent(object);
@@ -3450,7 +3450,7 @@ _WritePoints(_PrimWriterContext* context)
     const _WriterSchema& schema = context->GetSchema();
 
     // Create the object and make it the parent.
-    std::shared_ptr<Type> object(new Type(context->GetParent(),
+    shared_ptr<Type> object(new Type(context->GetParent(),
                                      context->GetAlembicPrimName(),
                                      _GetPrimMetadata(*context)));
     context->SetParent(object);
diff --git a/pxr/usd/plugin/usdAbc/wrapAlembicTest.cpp b/pxr/usd/plugin/usdAbc/wrapAlembicTest.cpp
index e5c6e8f10..8f0328dfb 100644
--- a/pxr/usd/plugin/usdAbc/wrapAlembicTest.cpp
+++ b/pxr/usd/plugin/usdAbc/wrapAlembicTest.cpp
@@ -27,12 +27,13 @@
 
 #include "pxr/usd/plugin/usdAbc/alembicTest.h"
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
 void wrapUsdAbcAlembicTest()
 {
-    boost::python::def("_TestAlembic", UsdAbc_TestAlembic, boost::python::arg("pathname"));
-    boost::python::def("_WriteAlembic", UsdAbc_WriteAlembic,
-        (boost::python::arg("srcPathname"), boost::python::arg("dstPathname")));
+    def("_TestAlembic", UsdAbc_TestAlembic, arg("pathname"));
+    def("_WriteAlembic", UsdAbc_WriteAlembic,
+        (arg("srcPathname"), arg("dstPathname")));
 }
diff --git a/pxr/usd/plugin/usdDraco/wrapDraco.cpp b/pxr/usd/plugin/usdDraco/wrapDraco.cpp
index 4260eeb50..cfb2788e0 100644
--- a/pxr/usd/plugin/usdDraco/wrapDraco.cpp
+++ b/pxr/usd/plugin/usdDraco/wrapDraco.cpp
@@ -28,21 +28,22 @@
 
 #include <boost/python/def.hpp>
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
 void wrapUsdDraco()
 {
-    boost::python::def("_WriteDraco", UsdDraco_WriteDraco,
-        (boost::python::arg("mesh"),
-         boost::python::arg("fileName"),
-         boost::python::arg("qp"),
-         boost::python::arg("qt"),
-         boost::python::arg("qn"),
-         boost::python::arg("cl"),
-         boost::python::arg("preservePolygons"),
-         boost::python::arg("preservePositionOrder"),
-         boost::python::arg("preserveHoles")));
-    boost::python::def("_PrimvarSupported", UsdDraco_PrimvarSupported,
-        (boost::python::arg("primvar")));
+    def("_WriteDraco", UsdDraco_WriteDraco,
+        (arg("mesh"),
+         arg("fileName"),
+         arg("qp"),
+         arg("qt"),
+         arg("qn"),
+         arg("cl"),
+         arg("preservePolygons"),
+         arg("preservePositionOrder"),
+         arg("preserveHoles")));
+    def("_PrimvarSupported", UsdDraco_PrimvarSupported,
+        (arg("primvar")));
 }
diff --git a/pxr/usd/plugin/usdMtlx/wrapBackdoor.cpp b/pxr/usd/plugin/usdMtlx/wrapBackdoor.cpp
index 74af3a2dc..d62cef562 100644
--- a/pxr/usd/plugin/usdMtlx/wrapBackdoor.cpp
+++ b/pxr/usd/plugin/usdMtlx/wrapBackdoor.cpp
@@ -29,15 +29,16 @@
 
 #include <boost/python/def.hpp>
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
 void wrapUsdMtlxBackdoor()
 {
-    boost::python::def("_TestString", UsdMtlx_TestString,
-        (boost::python::arg("buffer"), boost::python::arg("nodeGraphs") = false),
-        boost::python::return_value_policy<TfPyRefPtrFactory<>>());
-    boost::python::def("_TestFile", UsdMtlx_TestFile,
-        (boost::python::arg("pathname"), boost::python::arg("nodeGraphs") = false),
-        boost::python::return_value_policy<TfPyRefPtrFactory<>>());
+    def("_TestString", UsdMtlx_TestString,
+        (arg("buffer"), arg("nodeGraphs") = false),
+        return_value_policy<TfPyRefPtrFactory<>>());
+    def("_TestFile", UsdMtlx_TestFile,
+        (arg("pathname"), arg("nodeGraphs") = false),
+        return_value_policy<TfPyRefPtrFactory<>>());
 }
diff --git a/pxr/usd/sdf/layerRegistry.h b/pxr/usd/sdf/layerRegistry.h
index dd23ff8a8..9c9dfd659 100644
--- a/pxr/usd/sdf/layerRegistry.h
+++ b/pxr/usd/sdf/layerRegistry.h
@@ -149,13 +149,13 @@ private:
         > _Layers;
 
     // Identity index.
-    typedef boost::multi_index::index<by_identity>::type _LayersByIdentity;
+    typedef _Layers::index<by_identity>::type _LayersByIdentity;
     // Identifier index.
-    typedef boost::multi_index::index<by_identifier>::type _LayersByIdentifier;
+    typedef _Layers::index<by_identifier>::type _LayersByIdentifier;
     // Real path index.
-    typedef boost::multi_index::index<by_real_path>::type _LayersByRealPath;
+    typedef _Layers::index<by_real_path>::type _LayersByRealPath;
     // Repository path index.
-    typedef boost::multi_index::index<by_repository_path>::type _LayersByRepositoryPath;
+    typedef _Layers::index<by_repository_path>::type _LayersByRepositoryPath;
 
     _Layers _layers;
 };
diff --git a/pxr/usd/sdf/listOp.cpp b/pxr/usd/sdf/listOp.cpp
index 09729ffc8..0a48f673f 100644
--- a/pxr/usd/sdf/listOp.cpp
+++ b/pxr/usd/sdf/listOp.cpp
@@ -861,8 +861,8 @@ SDF_INSTANTIATE_LIST_OP(SdfReference);
 SDF_INSTANTIATE_LIST_OP(SdfPayload);
 
 template
-SDF_API void SdfApplyListOrdering(std::vector<string>* v, 
-                          const std::vector<string>& order);
+SDF_API void SdfApplyListOrdering(std::vector<std::string>* v, 
+                          const std::vector<std::string>& order);
 template
 SDF_API void SdfApplyListOrdering(std::vector<TfToken>* v, 
                           const std::vector<TfToken>& order);
diff --git a/pxr/usd/sdf/path.lex.cpp b/pxr/usd/sdf/path.lex.cpp
index b18af4b2d..ac1566249 100644
--- a/pxr/usd/sdf/path.lex.cpp
+++ b/pxr/usd/sdf/path.lex.cpp
@@ -741,6 +741,7 @@ static yyconst flex_int32_t yy_ec[256] =
 #endif
 
 
+
 PXR_NAMESPACE_USING_DIRECTIVE
 
 // As a pure parser, we must define the following
diff --git a/pxr/usd/sdf/path.ll b/pxr/usd/sdf/path.ll
index 4a04316cc..81847e2c4 100644
--- a/pxr/usd/sdf/path.ll
+++ b/pxr/usd/sdf/path.ll
@@ -38,7 +38,7 @@
 #define isatty(fd) ArchFileIsaTTY(fd)
 #endif
 
-using std::string;
+
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
diff --git a/pxr/usd/sdf/path.tab.cpp b/pxr/usd/sdf/path.tab.cpp
index 425d20cb5..45dbda11d 100644
--- a/pxr/usd/sdf/path.tab.cpp
+++ b/pxr/usd/sdf/path.tab.cpp
@@ -113,6 +113,9 @@
 #include <vector>
 
 
+
+
+
 PXR_NAMESPACE_USING_DIRECTIVE
 
 //--------------------------------------------------------------------
diff --git a/pxr/usd/sdf/path.yy b/pxr/usd/sdf/path.yy
index 2608a3e98..58fc7e4e3 100644
--- a/pxr/usd/sdf/path.yy
+++ b/pxr/usd/sdf/path.yy
@@ -34,9 +34,9 @@
 #include <utility>
 #include <vector>
 
-using std::pair;
-using std::string;
-using std::vector;
+
+
+
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
diff --git a/pxr/usd/sdf/textFileFormat.lex.cpp b/pxr/usd/sdf/textFileFormat.lex.cpp
index 427170bb3..d56b6a948 100644
--- a/pxr/usd/sdf/textFileFormat.lex.cpp
+++ b/pxr/usd/sdf/textFileFormat.lex.cpp
@@ -4250,6 +4250,8 @@ static yyconst flex_int32_t yy_ec[256] =
 #endif
 
 
+
+
 PXR_NAMESPACE_USING_DIRECTIVE
 
 #define YYSTYPE Sdf_ParserHelpers::Value
diff --git a/pxr/usd/sdf/textFileFormat.ll b/pxr/usd/sdf/textFileFormat.ll
index 3266b62ce..975eb52da 100644
--- a/pxr/usd/sdf/textFileFormat.ll
+++ b/pxr/usd/sdf/textFileFormat.ll
@@ -40,8 +40,8 @@
 #define isatty(fd) ArchFileIsaTTY(fd)
 #endif
 
-using std::map;
-using std::vector;
+
+
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
diff --git a/pxr/usd/sdf/textFileFormat.tab.cpp b/pxr/usd/sdf/textFileFormat.tab.cpp
index d6cee2a2d..7d4c37e42 100644
--- a/pxr/usd/sdf/textFileFormat.tab.cpp
+++ b/pxr/usd/sdf/textFileFormat.tab.cpp
@@ -148,6 +148,7 @@ PXR_NAMESPACE_USING_DIRECTIVE
 
 using Sdf_ParserHelpers::Value;
 
+
 //--------------------------------------------------------------------
 // Helper macros/functions for handling errors
 //--------------------------------------------------------------------
diff --git a/pxr/usd/sdf/textFileFormat.yy b/pxr/usd/sdf/textFileFormat.yy
index bb894fec9..20f0814eb 100644
--- a/pxr/usd/sdf/textFileFormat.yy
+++ b/pxr/usd/sdf/textFileFormat.yy
@@ -69,7 +69,7 @@
 PXR_NAMESPACE_USING_DIRECTIVE
 
 using Sdf_ParserHelpers::Value;
-using boost::get;
+
 
 //--------------------------------------------------------------------
 // Helper macros/functions for handling errors
diff --git a/pxr/usd/usd/stage.cpp b/pxr/usd/usd/stage.cpp
index 08a9eaf32..ee28d44f0 100644
--- a/pxr/usd/usd/stage.cpp
+++ b/pxr/usd/usd/stage.cpp
@@ -3726,8 +3726,8 @@ static std::string
 _Stringify(const ChangedPaths& paths)
 {
     return _Stringify(SdfPathVector(
-        make_transform_iterator(paths.begin(), TfGet<0>()),
-        make_transform_iterator(paths.end(), TfGet<0>())));
+        boost::make_transform_iterator(paths.begin(), TfGet<0>()),
+        boost::make_transform_iterator(paths.end(), TfGet<0>())));
 }
 
 // Add paths in the given cache that depend on the given path in the given 
@@ -4407,8 +4407,8 @@ UsdStage::_RecomposePrims(T *pathsToRecompose)
     // around this.
     std::vector<Usd_PrimDataPtr> subtreesToRecompose;
     _ComputeSubtreesToRecompose(
-        make_transform_iterator(pathsToRecompose->begin(), TfGet<0>()),
-        make_transform_iterator(pathsToRecompose->end(), TfGet<0>()),
+        boost::make_transform_iterator(pathsToRecompose->begin(), TfGet<0>()),
+        boost::make_transform_iterator(pathsToRecompose->end(), TfGet<0>()),
         &subtreesToRecompose);
 
     // Recompose subtrees.
diff --git a/pxr/usd/usd/stageCache.cpp b/pxr/usd/usd/stageCache.cpp
index 9087ca773..a8dfebe7c 100644
--- a/pxr/usd/usd/stageCache.cpp
+++ b/pxr/usd/usd/stageCache.cpp
@@ -102,9 +102,9 @@ typedef boost::multi_index::multi_index_container<
         >
     > StageContainer;
 
-typedef boost::multi_index::index<ById>::type StagesById;
-typedef boost::multi_index::index<ByStage>::type StagesByStage;
-typedef boost::multi_index::index<ByRootLayer>::type StagesByRootLayer;
+typedef StageContainer::index<ById>::type StagesById;
+typedef StageContainer::index<ByStage>::type StagesByStage;
+typedef StageContainer::index<ByRootLayer>::type StagesByRootLayer;
 
 // Walk range, which must be from index, applying pred() to every element.  For
 // those elements where pred(element) is true, erase the element from the index
diff --git a/pxr/usdImaging/usdAppUtils/wrapCamera.cpp b/pxr/usdImaging/usdAppUtils/wrapCamera.cpp
index 26f334b63..9268c7ac6 100644
--- a/pxr/usdImaging/usdAppUtils/wrapCamera.cpp
+++ b/pxr/usdImaging/usdAppUtils/wrapCamera.cpp
@@ -27,6 +27,7 @@
 #include <boost/python.hpp>
 #include <boost/python/def.hpp>
 
+using namespace boost::python;
 
 
 PXR_NAMESPACE_USING_DIRECTIVE
@@ -35,8 +36,8 @@ PXR_NAMESPACE_USING_DIRECTIVE
 void
 wrapCamera()
 {
-    boost::python::def(
+    def(
         "GetCameraAtPath",
         UsdAppUtilsGetCameraAtPath,
-        (boost::python::arg("stage"), boost::python::arg("cameraPath")));
+        (arg("stage"), arg("cameraPath")));
 }
diff --git a/pxr/usdImaging/usdAppUtils/wrapFrameRecorder.cpp b/pxr/usdImaging/usdAppUtils/wrapFrameRecorder.cpp
index d279ea6ad..4b1041b7b 100644
--- a/pxr/usdImaging/usdAppUtils/wrapFrameRecorder.cpp
+++ b/pxr/usdImaging/usdAppUtils/wrapFrameRecorder.cpp
@@ -29,6 +29,7 @@
 #include <boost/python/def.hpp>
 #include <boost/python/scope.hpp>
 
+using namespace boost::python;
 
 
 PXR_NAMESPACE_USING_DIRECTIVE
@@ -39,21 +40,21 @@ wrapFrameRecorder()
 {
     using This = UsdAppUtilsFrameRecorder;
 
-    boost::python::scope s = boost::python::class_<This, boost::noncopyable>("FrameRecorder")
-        .def(boost::python::init<>())
+    scope s = class_<This, boost::noncopyable>("FrameRecorder")
+        .def(init<>())
         .def("GetCurrentRendererId", &This::GetCurrentRendererId)
         .def("SetRendererPlugin", &This::SetRendererPlugin)
         .def("SetImageWidth", &This::SetImageWidth)
         .def("SetComplexity", &This::SetComplexity)
         .def("SetColorCorrectionMode", &This::SetColorCorrectionMode)
         .def("SetIncludedPurposes", &This::SetIncludedPurposes,
-             (boost::python::arg("purposes")))
+             (arg("purposes")))
         .def(
             "Record",
             &This::Record,
-            (boost::python::arg("stage"),
-             boost::python::arg("usdCamera"),
-             boost::python::arg("timeCode"),
-             boost::python::arg("outputImagePath")))
+            (arg("stage"),
+             arg("usdCamera"),
+             arg("timeCode"),
+             arg("outputImagePath")))
     ;
 }
diff --git a/pxr/usdImaging/usdImaging/instanceAdapter.cpp b/pxr/usdImaging/usdImaging/instanceAdapter.cpp
index 820dccf70..7327b8a46 100644
--- a/pxr/usdImaging/usdImaging/instanceAdapter.cpp
+++ b/pxr/usdImaging/usdImaging/instanceAdapter.cpp
@@ -945,7 +945,7 @@ struct UsdImagingInstanceAdapter::_IsInstanceTransformVaryingFn
 
     // We keep a simple cache directly on _IsInstanceTransformVaryingFn because
     // we only need it during initialization and resyncs (not in UpdateForTime).
-    boost::unordered::unordered_map<UsdPrim, bool, boost::hash<UsdPrim>> cache;
+    boost::unordered_map<UsdPrim, bool, boost::hash<UsdPrim>> cache;
 };
 
 bool 
@@ -2307,7 +2307,7 @@ struct UsdImagingInstanceAdapter::_ComputeInstanceMapVariabilityFn
     // We keep a simple cache of visibility varying states directly on
     // _ComputeInstanceMapVariabilityFn because we only need it for the
     // variability calculation and during resyncs.
-    boost::unordered::unordered_map<UsdPrim, bool, boost::hash<UsdPrim>> varyingCache;
+    boost::unordered_map<UsdPrim, bool, boost::hash<UsdPrim>> varyingCache;
     const UsdImagingInstanceAdapter* adapter;
     std::vector<_InstancerData::Visibility>* visibility;
 };
diff --git a/pxr/usdImaging/usdImagingGL/wrapEngine.cpp b/pxr/usdImaging/usdImagingGL/wrapEngine.cpp
index 1f3e6e321..37e9180d9 100644
--- a/pxr/usdImaging/usdImagingGL/wrapEngine.cpp
+++ b/pxr/usdImaging/usdImagingGL/wrapEngine.cpp
@@ -36,6 +36,9 @@
 #include "pxr/base/tf/pyEnum.h"
 #include "pxr/base/tf/pyResultConversions.h"
 
+using namespace std;
+using namespace boost::python;
+using namespace boost;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -87,9 +90,9 @@ _SetLightingState(UsdImagingGLEngine &self, GlfSimpleLightVector const &lights,
 }
 
 void _SetOverrideWindowPolicy(UsdImagingGLEngine & self,
-                              const boost::python::object &pyObj)
+                              const object &pyObj)
 {
-    boost::python::extract<CameraUtilConformWindowPolicy> extractor(pyObj);
+    extract<CameraUtilConformWindowPolicy> extractor(pyObj);
     if (extractor.check()) {
         self.SetOverrideWindowPolicy({true, extractor()});
     } else {
@@ -102,10 +105,10 @@ void _SetOverrideWindowPolicy(UsdImagingGLEngine & self,
 void wrapEngine()
 {
     { 
-        boost::python::scope engineScope = boost::python::class_<UsdImagingGLEngine, boost::noncopyable>(
+        scope engineScope = class_<UsdImagingGLEngine, boost::noncopyable>(
                 "Engine", "UsdImaging Renderer class")
-            .def( boost::python::init<>() )
-            .def( boost::python::init<const SdfPath &, const SdfPathVector&,
+            .def( init<>() )
+            .def( init<const SdfPath &, const SdfPathVector&,
                     const SdfPathVector& >() )
             .def("Render", &UsdImagingGLEngine::Render)
             .def("SetWindowPolicy", &UsdImagingGLEngine::SetWindowPolicy)
@@ -126,7 +129,7 @@ void wrapEngine()
                 .staticmethod("IsHydraEnabled")
             .def("IsConverged", &UsdImagingGLEngine::IsConverged)
             .def("GetRendererPlugins", &UsdImagingGLEngine::GetRendererPlugins,
-                 boost::python::return_value_policy< TfPySequenceToList >())
+                 return_value_policy< TfPySequenceToList >())
                 .staticmethod("GetRendererPlugins")
             .def("GetRendererDisplayName", 
                     &UsdImagingGLEngine::GetRendererDisplayName)
@@ -137,14 +140,14 @@ void wrapEngine()
                     &UsdImagingGLEngine::SetRendererPlugin)
             .def("GetRendererAovs", 
                     &UsdImagingGLEngine::GetRendererAovs,
-                 boost::python::return_value_policy< TfPySequenceToList >())
+                 return_value_policy< TfPySequenceToList >())
             .def("SetRendererAov", 
                     &UsdImagingGLEngine::SetRendererAov)
             .def("GetRenderStats", 
                     &UsdImagingGLEngine::GetRenderStats)
             .def("GetRendererSettingsList", 
                     &UsdImagingGLEngine::GetRendererSettingsList,
-                 boost::python::return_value_policy< TfPySequenceToList >())
+                 return_value_policy< TfPySequenceToList >())
             .def("GetRendererSetting", &UsdImagingGLEngine::GetRendererSetting)
             .def("SetRendererSetting", &UsdImagingGLEngine::SetRendererSetting)
             .def("SetColorCorrectionSettings", 
@@ -154,7 +157,7 @@ void wrapEngine()
                 .staticmethod("IsColorCorrectionCapable")
             .def("GetRendererCommandDescriptors",
                 &UsdImagingGLEngine::GetRendererCommandDescriptors,
-                boost::python::return_value_policy< TfPySequenceToList >() )
+                return_value_policy< TfPySequenceToList >() )
             .def("InvokeRendererCommand",
                 &UsdImagingGLEngine::InvokeRendererCommand,
                 (boost::python::arg("command"),
@@ -175,7 +178,7 @@ void wrapEngine()
     }
 
     // Wrap the constants.
-    boost::python::scope().attr("ALL_INSTANCES") = UsdImagingDelegate::ALL_INSTANCES;
+    scope().attr("ALL_INSTANCES") = UsdImagingDelegate::ALL_INSTANCES;
 
     TfPyContainerConversions::from_python_sequence<
         std::vector<GlfSimpleLight>, 
diff --git a/pxr/usdImaging/usdImagingGL/wrapRenderParams.cpp b/pxr/usdImaging/usdImagingGL/wrapRenderParams.cpp
index 3f412b1ac..bfa050409 100644
--- a/pxr/usdImaging/usdImagingGL/wrapRenderParams.cpp
+++ b/pxr/usdImaging/usdImagingGL/wrapRenderParams.cpp
@@ -29,6 +29,7 @@
 
 #include "pxr/usdImaging/usdImagingGL/renderParams.h"
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -36,7 +37,7 @@ void
 wrapRenderParams()
 {
     // Wrap the DrawMode enum. Accessible as UsdImagingGL.DrawMode
-    boost::python::enum_<UsdImagingGLDrawMode>("DrawMode")
+    enum_<UsdImagingGLDrawMode>("DrawMode")
         .value("DRAW_POINTS", UsdImagingGLDrawMode::DRAW_POINTS)
         .value("DRAW_WIREFRAME", UsdImagingGLDrawMode::DRAW_WIREFRAME)
         .value("DRAW_WIREFRAME_ON_SURFACE", 
@@ -49,7 +50,7 @@ wrapRenderParams()
         ;
 
     // Wrap the CullStyle enum. Accessible as UsdImagingGL.CullStyle
-    boost::python::enum_<UsdImagingGLCullStyle>("CullStyle")
+    enum_<UsdImagingGLCullStyle>("CullStyle")
         .value("CULL_STYLE_NOTHING", UsdImagingGLCullStyle::CULL_STYLE_NOTHING)
         .value("CULL_STYLE_BACK", UsdImagingGLCullStyle::CULL_STYLE_BACK)
         .value("CULL_STYLE_FRONT", UsdImagingGLCullStyle::CULL_STYLE_FRONT)
@@ -60,7 +61,7 @@ wrapRenderParams()
     // Wrap the UsdImagingGLRenderParams struct. Accessible as 
     // UsdImagingGL.RenderParams
     using Params = UsdImagingGLRenderParams;
-    boost::python::class_<UsdImagingGLRenderParams>("RenderParams", "Render parameters")
+    class_<UsdImagingGLRenderParams>("RenderParams", "Render parameters")
         .def_readwrite("frame", &Params::frame)
         .def_readwrite("complexity", &Params::complexity)
         .def_readwrite("drawMode", &Params::drawMode)
diff --git a/pxr/usdImaging/usdImagingGL/wrapRendererCommands.cpp b/pxr/usdImaging/usdImagingGL/wrapRendererCommands.cpp
index ff8a290f2..8fdc54e52 100644
--- a/pxr/usdImaging/usdImagingGL/wrapRendererCommands.cpp
+++ b/pxr/usdImaging/usdImagingGL/wrapRendererCommands.cpp
@@ -30,6 +30,7 @@
 
 #include "pxr/imaging/hd/command.h"
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -42,13 +43,13 @@ wrapRendererCommands()
 {
     // Wrap the UsdImagingGLRendererCommandArgDescriptor struct.
     // Accessible as UsdImagingGL.RendererCommandArgDescriptor
-    boost::python::class_<UsdImagingGLRendererCommandArgDescriptor>(
+    class_<UsdImagingGLRendererCommandArgDescriptor>(
             "RendererCommandArgDescriptor",
-            "Renderer Command Argument Metadata", boost::python::no_init)
+            "Renderer Command Argument Metadata", no_init)
         .add_property("argName", 
-                boost::python::make_getter(
+                make_getter(
                     &UsdImagingGLRendererCommandArgDescriptor::argName,
-                    boost::python::return_value_policy<boost::python::return_by_value>()))
+                    return_value_policy<return_by_value>()))
 
         .def_readonly("defaultValue",
                   &UsdImagingGLRendererCommandArgDescriptor::defaultValue)
@@ -58,12 +59,12 @@ wrapRendererCommands()
 
     // Wrap the UsdImagingGLRendererCommandDescriptor struct.
     // Accessible as UsdImagingGL.RendererCommandDescriptor
-    boost::python::class_<UsdImagingGLRendererCommandDescriptor>("RendererCommandDescriptor",
-            "Renderer Command Metadata", boost::python::no_init)
+    class_<UsdImagingGLRendererCommandDescriptor>("RendererCommandDescriptor",
+            "Renderer Command Metadata", no_init)
         .add_property("commandName", 
-                boost::python::make_getter(
+                make_getter(
                     &UsdImagingGLRendererCommandDescriptor::commandName,
-                    boost::python::return_value_policy<boost::python::return_by_value>()))
+                    return_value_policy<return_by_value>()))
 
         .def_readonly("commandDescription",
                   &UsdImagingGLRendererCommandDescriptor::commandDescription)
diff --git a/pxr/usdImaging/usdImagingGL/wrapRendererSettings.cpp b/pxr/usdImaging/usdImagingGL/wrapRendererSettings.cpp
index 235093cf4..0bdc2083e 100644
--- a/pxr/usdImaging/usdImagingGL/wrapRendererSettings.cpp
+++ b/pxr/usdImaging/usdImagingGL/wrapRendererSettings.cpp
@@ -29,6 +29,7 @@
 
 #include "pxr/usdImaging/usdImagingGL/rendererSettings.h"
 
+using namespace boost::python;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -37,7 +38,7 @@ wrapRendererSettings()
 {
     // Wrap the UsdImagingGLRendererSetting::Type enum. Accessible as
     // UsdImagingGL.RendererSettingType.
-    boost::python::enum_<UsdImagingGLRendererSetting::Type>("RendererSettingType")
+    enum_<UsdImagingGLRendererSetting::Type>("RendererSettingType")
             .value("FLAG", UsdImagingGLRendererSetting::TYPE_FLAG)
             .value("INT", UsdImagingGLRendererSetting::TYPE_INT)
             .value("FLOAT", UsdImagingGLRendererSetting::TYPE_FLOAT)
@@ -47,13 +48,13 @@ wrapRendererSettings()
     // Wrap the UsdImagingGLRendererSetting struct.
     // Accessible as UsdImagingGL.RendererSetting
     typedef UsdImagingGLRendererSetting Setting;
-    boost::python::class_<UsdImagingGLRendererSetting>("RendererSetting",
+    class_<UsdImagingGLRendererSetting>("RendererSetting",
             "Renderer Setting Metadata")
-        .add_property("key", boost::python::make_getter(&Setting::key,
-                boost::python::return_value_policy<boost::python::return_by_value>()))
+        .add_property("key", make_getter(&Setting::key,
+                return_value_policy<return_by_value>()))
         .def_readonly("name", &Setting::name)
         .def_readonly("type", &Setting::type)
-        .add_property("defValue", boost::python::make_getter(&Setting::defValue,
-                boost::python::return_value_policy<boost::python::return_by_value>()))
+        .add_property("defValue", make_getter(&Setting::defValue,
+                return_value_policy<return_by_value>()))
         ;
 }
diff --git a/pxr/usdImaging/usdviewq/wrapUtils.cpp b/pxr/usdImaging/usdviewq/wrapUtils.cpp
index 69dbc5fc5..09e1d2a74 100644
--- a/pxr/usdImaging/usdviewq/wrapUtils.cpp
+++ b/pxr/usdImaging/usdviewq/wrapUtils.cpp
@@ -33,6 +33,8 @@
 
 #include <vector>
 
+using namespace boost::python;
+using std::vector;
 
 PXR_NAMESPACE_USING_DIRECTIVE
 
@@ -41,7 +43,7 @@ namespace {
 // We return primInfo by unrolling it into a single tuple.  This allows
 // python clients to extract the information 40% faster than if we were
 // to wrap out UsdviewqUtils::PrimInfo directly.
-static boost::python::tuple
+static tuple
 _GetPrimInfo(UsdPrim const &prim, UsdTimeCode time)
 {
     UsdviewqUtils::PrimInfo info = UsdviewqUtils::GetPrimInfo(prim, time);
@@ -65,10 +67,10 @@ _GetPrimInfo(UsdPrim const &prim, UsdTimeCode time)
 void wrapUtils() {    
     typedef UsdviewqUtils This;
 
-    boost::python::scope utilsScope = boost::python::class_<This> ("Utils")
+    scope utilsScope = class_<This> ("Utils")
         .def("_GetAllPrimsOfType",
             This::_GetAllPrimsOfType,
-            boost::python::return_value_policy<TfPySequenceToList>())
+            return_value_policy<TfPySequenceToList>())
             .staticmethod("_GetAllPrimsOfType")
 
         .def("GetPrimInfo",
